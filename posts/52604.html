<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Spring高级49讲原笔记 | Pei</title><meta name="keywords" content="Java,Spring"><meta name="author" content="Pei"><meta name="copyright" content="Pei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Spring高级49讲原笔记"><meta name="application-name" content="Spring高级49讲原笔记"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Spring高级49讲原笔记"><meta property="og:url" content="https://blog.goku.top/posts/52604.html"><meta property="og:site_name" content="Pei"><meta property="og:description" content="B站黑马程序员视频原笔记，方便自己在手机上浏览，太喜欢满老师的授课方式了O(∩_∩)O，看代码demo都是认真设计的，真的是站在听课者的角度考虑，耐心讲解每一处细节原理"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://upyun.goku.top/blog/spring.png"><meta property="article:author" content="Pei"><meta property="article:tag" content="Java,Blog,ios,Android,玩机技巧"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://upyun.goku.top/blog/spring.png"><meta name="description" content="B站黑马程序员视频原笔记，方便自己在手机上浏览，太喜欢满老师的授课方式了O(∩_∩)O，看代码demo都是认真设计的，真的是站在听课者的角度考虑，耐心讲解每一处细节原理"><link rel="shortcut icon" href="https://upyun.goku.top/blog/icon.png!cover"><link rel="canonical" href="https://blog.goku.top/posts/52604"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="goku的博客"/><meta name="baidu-site-verification" content="goku的博客"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.14/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo.goku.top/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":8000,"accessToken":"08c2b11fbf834e2aa5af1730f757483e","mailMd5":"061B062512CCACAB05339BA10B9C6B05"},
  root: '/',
  preloader: undefined,
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🔨 Java开发小能手","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"该文章已发布","messageNext":"天，文章信息部分有效性请以实际为准。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Pei","link":"链接: ","source":"来源: Pei","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Pei',
  title: 'Spring高级49讲原笔记',
  postAI: '',
  pageFillDescription: '容器与 bean, 1) 容器接口, 演示1 - BeanFactory 与 ApplicationContext 的区别, 代码参考, 收获💡, 演示2 - 国际化, 2) 容器实现, 演示1 - DefaultListableBeanFactory, 代码参考, 收获💡, 演示2 - 常见 ApplicationContext 实现, 代码参考, 收获💡, 3) Bean 的生命周期, 演示1 - bean 生命周期, 代码参考, 收获💡, 演示2 - 模板方法设计模式, 关键代码, 演示3 - bean 后处理器排序, 代码参考, 收获💡, 4) Bean 后处理器, 演示1 - 后处理器作用, 代码参考, 收获💡, 演示2 - @Autowired bean 后处理器运行分析, 代码参考, 收获💡, 5) BeanFactory 后处理器, 演示1 - BeanFactory 后处理器的作用, 代码参考, 收获💡, 演示2 - 模拟解析 @ComponentScan, 代码参考, 收获💡, 演示3 - 模拟解析 @Bean, 代码参考, 收获💡, 演示4 - 模拟解析 Mapper 接口, 代码参考, 收获💡, 6) Aware 接口, 演示 - Aware 接口及 InitializingBean 接口, 代码参考, 收获💡, 配置类 @Autowired 失效分析, 7) 初始化与销毁, 演示 - 初始化销毁顺序, 代码参考, 收获💡, 8) Scope, 演示1 - request session application 作用域, 代码参考, 收获💡, 分析 - singleton 注入其它 scope 失效, 演示2 - 4种解决方法, 代码参考, 收获💡, AOP, 9) AOP 实现之 ajc 编译器, 收获💡, 10) AOP 实现之 agent 类加载, 收获💡, 11) AOP 实现之 proxy, 演示1 - jdk 动态代理, 收获💡, 演示2 - cglib 代理, 收获💡, 12) jdk 动态代理进阶, 演示1 - 模拟 jdk 动态代理, 收获💡, 演示2 - 方法反射优化, 代码参考, 收获💡, 13) cglib 代理进阶, 演示 - 模拟 cglib 代理, 代码参考, 收获💡, 14) cglib 避免反射调用, 演示 - cglib 如何避免反射, 代码参考, 收获💡, 15) jdk 和 cglib 在 Spring 中的统一, 演示 - 底层切点、通知、切面, 代码参考, 收获💡, 16) 切点匹配, 演示 - 切点匹配, 代码参考, 收获💡, 17) 从 @Aspect 到 Advisor, 演示1 - 代理创建器, 代码参考, 收获💡, 演示2 - 代理创建时机, 代码参考, 收获💡, 演示3 - @Before 对应的低级通知, 代码参考, 收获💡, 18) 静态通知调用, 演示1 - 通知调用过程, 代码参考, 收获💡, 演示2 - 模拟 MethodInvocation, 代码参考, 收获💡, 19) 动态通知调用, 演示 - 带参数绑定的通知方法调用, 代码参考, 收获💡, WEB, 20) RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter, 演示1 - DispatcherServlet 初始化, 代码参考, 收获💡, 演示2 - 自定义参数与返回值处理器, 代码参考, 收获💡, 21) 参数解析器, 演示 - 常见参数解析器, 代码参考, 收获💡, 22) 参数名解析, 演示 - 两种方法获取参数名, 代码参考, 收获💡, 23) 对象绑定与类型转换, 底层第一套转换接口与实现, 底层第二套转换接口, 高层接口与实现, 演示1 - 类型转换与数据绑定, 代码参考, 收获💡, 演示2 - 数据绑定工厂, 代码参考, 收获💡, 演示3 - 获取泛型参数, 代码参考, 收获💡, 24) @ControllerAdvice 之 @InitBinder, 演示 - 准备 @InitBinder, 收获💡, 25) 控制器方法执行流程, 图1, 图2, 图3, 26) @ControllerAdvice 之 @ModelAttribute, 演示 - 准备 @ModelAttribute, 代码参考, 收获💡, 27) 返回值处理器, 演示 - 常见返回值处理器, 代码参考, 收获💡, 28) MessageConverter, 演示 - MessageConverter 的作用, 代码参考, 收获💡, 29) @ControllerAdvice 之 ResponseBodyAdvice, 演示 - ResponseBodyAdvice 增强, 代码参考, 收获💡, 30) 异常解析器, 演示 - ExceptionHandlerExceptionResolver, 代码参考, 收获💡, 31) @ControllerAdvice 之 @ExceptionHandler, 演示 - 准备 @ExceptionHandler, 代码参考, 收获💡, 32) Tomcat 异常处理, 演示1 - 错误页处理, 关键代码, 收获💡, 演示2 - BasicErrorController, 关键代码, 收获💡, 33) BeanNameUrlHandlerMapping 与 SimpleControllerHandlerAdapter, 演示 - 本组映射器和适配器, 关键代码, 收获💡, 34) RouterFunctionMapping 与 HandlerFunctionAdapter, 演示 - 本组映射器和适配器, 关键代码, 收获💡, 35) SimpleUrlHandlerMapping 与 HttpRequestHandlerAdapter, 演示1 - 本组映射器和适配器, 代码参考, 关键代码, 收获💡, 演示2 - 静态资源解析优化, 关键代码, 收获💡, 演示3 - 欢迎页, 关键代码, 收获💡, 映射器与适配器小结, 36) mvc 处理流程, Boot, 37) Boot 骨架项目, 38) Boot War项目, 测试, 启示, 39) Boot 启动过程, 演示 - 启动过程, 收获💡, 40) Tomcat 内嵌容器, 演示1 - Tomcat 内嵌容器, 关键代码, 演示2 - 集成 Spring 容器, 关键代码, 41) Boot 自动配置, AopAutoConfiguration, DataSourceAutoConfiguration, MybatisAutoConfiguration, TransactionAutoConfiguration, ServletWebServerFactoryAutoConfiguration, DispatcherServletAutoConfiguration, WebMvcAutoConfiguration, ErrorMvcAutoConfiguration, MultipartAutoConfiguration, HttpEncodingAutoConfiguration, 演示 - 自动配置类原理, 关键代码, 收获💡, 42) 条件装配底层, 收获💡, 其它, 43) FactoryBean, 演示 - FactoryBean, 代码参考, 收获💡, 44) @Indexed 原理, 演示 - @Indexed, 代码参考, 收获💡, 45) 代理进一步理解, 演示 - 代理, 代码参考, 收获💡, 46) @Value 装配底层, 按类型装配的步骤, 演示 - @Value 装配过程, 代码参考, 收获💡, 47) @Autowired 装配底层, 演示 - @Autowired 装配过程, 代码参考, 收获💡, 48) 事件监听器, 演示 - 事件监听器, 代码参考, 收获💡, 49) 事件发布器, 演示 - 事件发布器, 代码参考, 收获💡容器与容器接口接口典型功能有接口是的子接口它扩展了接口的功能如国际化通配符方式获取一组资源整合环境能通过它获取各种来源的配置信息事件发布与监听实现组件之间的解耦可以看到我们课上讲的都是提供的基本功能中的扩展功能都没有用到演示与的区别代码参考包收获通过这个示例结合查看对象的内部结构学到到底什么是它是的父接口它才是的核心容器主要的实现都组合了它的功能组合是指的一个重要成员变量就是能干点啥表面上只有实际上控制反转基本的依赖注入直至的生命周期的各种功能都由它的实现类提供例子中通过反射查看了它的成员变量内部包含了所有的单例比多点啥组合并扩展了的功能国际化通配符方式获取一组资源整合环境事件发布与监听新学一种代码之间解耦途径事件解耦建议练习完成用户注册与发送短信之间的解耦用事件方式和方式分别实现注意如果运行时请添加这是因为这些版本的默认不允许跨反射事件发布还可以异步这个视频中没有展示请自行查阅的用法演示国际化国际化文件均在目录下空你好注意中的名字固定为使用时国际化文件名固定为空的也必须存在容器实现的发展历史较为悠久因此很多资料还在讲解它较旧的实现这里出于怀旧的原因把它们都列出来供大家参考是最重要的实现像控制反转和依赖注入功能都是它来实现从类路径查找配置文件创建容器旧从磁盘路径查找配置文件创建容器旧传统整合时基于配置文件的容器旧传统整合时基于配置类的容器旧中非环境容器新中环境容器新中环境容器新另外要注意的是后面这些带有的类都是接口的实现但它们是组合了的功能并非继承而来演示代码参考收获可以通过注册一个对象我们平时使用的配置类组件扫描等方式都是生成对象注册到当中描述了这个的创建蓝图是什么用构造还是工厂创建初始化销毁方法是什么等等需要手动调用后处理器对它做增强例如通过解析等注解来补充一些需要手动添加后处理器以便对后续的创建过程提供增强例如等注解的解析都是后处理器完成的后处理的添加顺序会对解析结果有影响见视频中同时加的例子需要手动调用方法来初始化单例需要额外设置才能解析与演示常见实现代码参考收获常见的容器实现内嵌容器的创建方法作用的生命周期一个受管理的生命周期主要阶段有创建根据的构造方法或者工厂方法来创建实例对象依赖注入根据或其它一些手段为的成员变量填充值建立关系初始化回调各种接口调用对象的各种初始化方法销毁在容器关闭时会销毁所有单例对象即调用它们的销毁方法对象也能够销毁不过需要容器这边主动调用一些资料会提到生命周期中还有一类后处理器会在的初始化的前后提供一些扩展逻辑但这种说法是不完整的见下面的演示演示生命周期代码参考包创建依赖注入依赖注入初始化初始化可用可用销毁创建前后的增强这里返回的对象若不为会替换掉原本的并且仅会走流程这里如果返回会跳过依赖注入阶段依赖注入前的增强如初始化前后的增强这里返回的对象会替换掉原本的如这里返回的对象会替换掉原本的如代理增强销毁之前的增强如收获生命周期各个阶段模板设计模式指大流程已经固定好了通过接口回调后处理器在一些关键点前后提供扩展演示模板方法设计模式关键代码解析解析模板方法构造依赖注入初始化对依赖注入阶段的扩展演示后处理器排序代码参考收获实现了接口的优先级最高实现了接口与加了注解的平级按数字升序其它的排在最后后处理器演示后处理器作用代码参考包收获等注解的解析属于生命周期阶段依赖注入初始化的扩展功能这些扩展功能由后处理器来完成每个后处理器各自增强什么功能解析与解析解析另外负责获取的值解析泛型等演示后处理器运行分析代码参考收获用来获取某个上加了的成员变量方法参数的信息表示为可以完成依赖注入内部根据成员变量方法参数封装为类型有了就可以利用方法进行基于类型的查找后处理器演示后处理器的作用代码参考包可以解析可以解析接口收获等注解的解析属于核心容器即的扩展功能这些扩展功能由不同的后处理器来完成其实主要就是补充了一些定义演示模拟解析代码参考收获操作元数据的工具类通过注解元数据获取直接或间接标注的注解信息通过类元数据获取类名生成名解析元数据是基于技术演示模拟解析代码参考收获进一步熟悉注解元数据获取方法上注解信息演示模拟解析接口代码参考收获接口被管理的本质实际是被作为注册到容器中的诡异做法根据接口生成的仅为根据接口名生成名接口演示接口及接口代码参考包收获接口提供了一种内置的注入手段例如注入的名字注入容器注入容器注入解析器接口提供了一种内置的初始化手段对比内置的注入和初始化不受扩展功能的影响总会被执行而扩展功能受某些情况影响可能会失效因此框架内部的类常用内置注入和初始化配置类失效分析配置类不包含的情况配置类执行注册创建和初始化依赖注入扩展如和初始化扩展如执行及创建成功配置类包含的情况因此要创建其中的必须提前创建配置类而此时的还未准备好导致等注解失效配置类创建和初始化执行及创建成功执行注册对应代码注入初始化注释或添加后处理器对应上方两种情况执行注意解决方法用内置依赖注入和初始化取代扩展依赖注入和初始化用静态工厂方法代替实例工厂方法避免工厂对象提前被创建初始化与销毁演示初始化销毁顺序代码参考包收获提供了多种初始化手段除了课堂上讲的之外还可以实现接口来进行初始化如果同一个用了以上手段声明了个初始化方法那么它们的执行顺序是标注的初始化方法接口的初始化方法指定的初始化方法与初始化类似也提供了多种销毁手段执行顺序为标注的销毁方法接口的销毁方法指定的销毁方法在当前版本的和程序中支持五种容器启动时创建未设置延迟容器关闭时销毁每次使用时创建不会自动销毁需要调用销毁每次请求用到此时创建请求结束时销毁每个会话用到此时创建会话结束时销毁容器用到此时创建容器停止时销毁有些文章提到有这一也是陈旧的说法目前中已废弃但要注意如果在注入其它都会有问题解决方法有演示作用域代码参考包打开不同的浏览器刷新即可查看效果如果运行时请添加收获有几种在中使用其它几种的方法其它的销毁时机可以将通过观察的销毁销毁机制疑似实现有误分析注入其它失效以单例注入多例为例有一个单例对象要注入的对象期望是多例测试输出发现它们是同一个对象而不是期望的多例对象对于单例对象来讲依赖注入仅发生了一次后续再没有用到多例的因此用的始终是第一次依赖注入的创建注入创建解决仍然使用生成代理代理对象虽然还是同一个但当每次使用代理对象的任意方法时由代理创建新的对象创建注入代理创建创建创建使用方法使用方法使用方法注意加在也可以加在成员变量上但加在方法上的目的是可以观察输出加在成员变量上就不行了加在方法的目的类似输出从输出日志可以看到调用方法时对象的类型是代理类型演示种解决方法代码参考包如果运行时请添加收获单例注入其它的四种解决方法解决方法虽然不同但理念上殊途同归都是推迟其它的获取底层实现方式之一是代理由代理结合通知和目标提供增强功能除此以外提供了两种另外的底层实现第一种是通过编译器在编译类文件时就把通知的增强功能织入到目标类的字节码中第二种是通过在加载目标类时修改目标类的字节码织入增强功能作为对比之前学习的代理是运行时生成新的字节码简单比较的话在编译和加载时修改目标字节码性能较高因为不用代理能突破一些技术上的限制例如对构造对静态方法对也能增强但侵入性较强且需要学习新的特有语法因此没有广泛流行实现之编译器代码参考项目收获编译器也能修改实现增强编译器增强能突破代理仅能通过方法重写增强的限制可以对构造方法静态方法等实现增强注意版本选择了因为目前的最高只支持到一定要用的来编译不会调用编译器实现之类加载代码参考项目收获类加载时可以通过修改实现增强实现之演示动态代理目标对象代理对象调用代理运行结果收获动态代理要求目标必须实现接口生成的代理类实现相同接口因此代理与目标之间是平级兄弟关系演示代理目标对象代理对象另一种调用方法不需要目标对象实例调用代理运行结果与动态代理相同收获不要求目标实现接口它生成的代理类是目标的子类因此代理与目标之间是子父关系限制根据上述分析类无法被增强动态代理进阶演示模拟动态代理创建代理这时传入进入功能增强反射调用目标方法调用代理方法模拟代理实现这就是代理类的源码秘密都在里面进入代理方法回调收获代理一点都不难无非就是利用了多态反射的知识方法重写可以增强逻辑只不过这增强逻辑千变万化不能写死在代理内部通过接口回调将增强逻辑置于代理类之外配合接口方法反射是多态调用就可以再联动调用目标方法会用的工具反编译代理类限制代理增强是借助多态来实现因此成员变量静态方法方法均不能通过代理实现演示方法反射优化代码参考收获前次反射性能较低第次调用会生成代理类优化为非反射调用会用的工具反编译第次调用生成的代理类注意运行时请添加代理进阶演示模拟代理代码参考包收获和动态代理原理查不多回调的接口换了一下改成了调用目标时有所改进见下面代码片段是反射调用必须调用到足够次数才会进行优化是不反射调用它会正常间接调用目标对象的方法采用也是不反射调用它会正常间接调用代理对象的方法可以省略目标对象调用目标方法三种反射调用非反射调用结合目标用非反射调用结合代理用调用代理方法注意调用的方法后两种在时都有问题需要避免反射调用演示如何避免反射代码参考收获当调用的或方法时会动态生成两个类配合代理对象一起使用避免反射配合目标对象一起使用避免反射用的这种记录了中方法与编号的对应关系编号编号编号首先根据方法名和参数个数类型用和找到这些方法编号然后再根据编号去调用目标方法又用了一大堆和但避免了反射记录了中方法与编号的对应关系不过额外提供了下面几个方法编号不增强仅是调用编号不增强仅是调用编号不增强仅是调用查找方式与类似为什么有这么麻烦的一套东西呢避免反射提高性能代价是一个代理类配两个类代理类中还得增加仅调用的一堆方法用编号处理方法对应关系比较省内存另外最初获得方法顺序是不确定的这个过程没法固定死和在中的统一中对切点通知切面的抽象如下切点接口典型实现通知典型接口为代表环绕通知切面包含一个通知包含一个通知和一个一一代理相关类图根据等设置选择实现通过创建代理对象图中都实现了接口能够获得关联的切面集合与目标其实是从取得调用代理方法时会借助将通知统一转为环绕通知多使用基于的基于的创建基于的创建基于的演示底层切点通知切面代码参考收获底层的切点实现底层的通知实现底层的切面实现用来创建代理如果指定了接口且使用如果没有指定接口或者使用例外如果目标是接口类型或已经是代理使用注意要区分本章节提到的它与之前中用的的是不同的接口切点匹配演示切点匹配代码参考收获常见切点用法切点的局限性实际的切点实现从到演示代理创建器代码参考包收获的作用将高级切面统一为低级切面在合适的时机创建代理找到有资格的有资格的一部分是低级的可以由自己编写如本例中的有资格的另一部分是高级的由解析后获得它内部调用只要返回集合不空则表示需要创建代理它的调用时机通常在原始对象初始化后执行但碰到循环依赖会提前至依赖注入之前执行演示代理创建时机代码参考收获代理的创建时机初始化之后无循环依赖时实例创建后依赖注入前有循环依赖时并暂存于二级缓存依赖注入与初始化不应该被增强仍应被施加于原始对象演示对应的低级通知代码参考收获前置通知会被转换为原始的形式该对象包含了如下信息通知代码从哪儿来切点是什么这里为啥要切点后面解释通知对象如何创建本例共用同一个对象类似的还有环绕通知环绕通知环绕通知静态通知调用代理对象调用流程如下以动态代理实现为例从获得和环绕通知链根据他俩创建简称首次执行发现有下一个环绕通知调用它的进入环绕通知执行前增强再次调用发现有下一个环绕通知调用它的进入环绕通知执行前增强调用发现没有环绕通知调用执行目标方法目标方法执行结束将结果返回给环绕通知执行环绕通知的后增强环绕通知继续将结果返回给环绕通知执行环绕通知的后增强环绕通知返回最终的结果图中不同颜色对应一次环绕通知或目标的调用起始至终结获得获得链创建前增强前增强结果后增强结果后增强结果演示通知调用过程代码参考收获代理方法执行时会做如下工作通过的将其他通知统一转换为环绕通知将适配为将适配为这体现的是适配器设计模式所谓静态通知体现在上面方法的部分这些通知调用时无需再次检查切点直接调用即可结合目标与环绕通知链创建对象通过它完成整个调用演示模拟代码参考收获方法调用链中下一个环绕通知每个环绕通知内部继续调用调用到没有更多通知了就调用目标方法的编程技巧在实现拦截器过滤器时能用上动态通知调用演示带参数绑定的通知方法调用代码参考收获通过的将其他通知统一转换为环绕通知所谓动态通知体现在上面方法的部分这些通知调用时因为要为通知方法绑定参数还需再次利用切点表达式动态通知调用复杂程度高性能较低与与俩是一对分别用来处理映射调用控制器方法并处理方法参数与方法返回值演示初始化代码参考包收获是在第一次被访问时执行初始化也可以通过配置修改为启动后就初始化在初始化时会从容器中找一些需要的组件如等并逐一调用它们的初始化初始化时会收集所有映射信息封装为其中是类型包括请求路径请求方法等信息是类型包括控制器方法对象控制器对象有了这个就可以在请求到达时快速完成映射找到并与匹配的拦截器一起返回给初始化时会准备调用时需要的各个组件如解析控制器方法参数处理控制器方法返回值演示自定义参数与返回值处理器代码参考收获体会参数解析器的作用体会返回值处理器的作用参数解析器演示常见参数解析器代码参考包收获初步了解的调用过程控制器方法被封装为准备对象绑定与类型转换准备用来存储中间结果解析每个参数值解析参数依赖的就是各种参数解析器它们都有两个重要方法判断是否支持方法参数解析方法参数常见参数的解析省略等省略组合模式在中的体现等注解中的参数名默认值都可以写成活的即从中获取参数名解析演示两种方法获取参数名代码参考收获如果编译时添加了可以生成参数表反射时就可以拿到参数名如果编译时添加了可以生成调试信息但分为两种情况普通类会包含局部变量表用可以拿到参数名接口不会包含局部变量表无法获得参数名这也是在实现接口时为何要提供注解来辅助获得参数名对象绑定与类型转换底层第一套转换接口与实现把其它类型转为把转为其它类型综合与功能把类型转为类型经过适配转换成放入集合利用其它们实现转换底层第二套转换接口多把与其它类型相互转换可以注册多个对象与第一套接口直接可以通过来进行适配高层接口与实现它们都实现了这个高层转换接口在转换时会用到委派与真正执行转换门面模式首先看是否有自定义转换器添加的即属于这种用了适配器模式把转为需要的再看有没有转换再利用默认的转换最后有一些特殊处理仅做类型转换为的属性赋值当需要时做类型转换走为的属性赋值当需要时做类型转换走为的属性执行绑定当需要时做类型转换根据选择走还是具备校验与获取校验结果功能演示类型转换与数据绑定代码参考包收获基本的类型转换与数据绑定用法演示数据绑定工厂代码参考收获的用法和扩展点可以解析控制器的标注方法作为扩展点添加自定义转换器控制器私有范围可以通过配置作为扩展点添加自定义转换器公共范围同时加了和的转换优先级优先采用的转换器其次使用的转换器使用默认转换器特殊处理例如有参构造演示获取泛型参数代码参考包收获获取泛型参数获取泛型参数之演示准备准备在整个调用过程中所处的位置准备准备添加数据获取有的解析器涉及有的解析器涉及数据绑定生成数据得到处理有的处理器涉及添加数据处理视图名是否渲染等获取在图中缩写为在图中缩写为在图中缩写为收获初始化时会解析中的方法会以类为单位在该类首次使用时解析此类的方法以上两种的解析结果都会缓存来避免重复解析控制器方法调用时会综合利用本类的方法和中的方法创建绑定工厂控制器方法执行流程图需要即是哪个即是中的哪个方法需要负责对象绑定类型转换负责参数名解析负责解析参数负责处理返回值图准备准备添加数据图获取有的解析器涉及有的解析器涉及数据绑定生成模型数据得到处理有的处理器涉及添加数据处理视图名是否渲染等获取之演示准备代码参考包准备在整个调用过程中所处的位置准备准备添加数据获取有的解析器涉及有的解析器涉及数据绑定生成数据得到处理有的处理器涉及添加数据处理视图名是否渲染等获取收获初始化时会解析中的方法会以类为单位在该类首次使用时解析此类的方法以上两种的解析结果都会缓存来避免重复解析控制器方法调用时会综合利用本类的方法和中的方法创建模型工厂返回值处理器演示常见返回值处理器代码参考包收获常见的返回值处理器分别获取其模型和视图名放入返回值类型为时把它当做视图名放入返回值添加了注解时将返回值作为模型放入此时需找到默认视图名返回值省略注解且返回非简单类型时将返回值作为模型放入此时需找到默认视图名返回值类型为时此时走并设置为返回值类型为时会设置为返回值添加了注解时此时走并设置为组合模式在中的体现演示的作用代码参考收获的作用是返回值处理器解析的但具体转换工作是做的如何选择首先看上有没有指定其次看的头有没有指定最后按的顺序谁能谁先转换之演示增强代码参考包增强在整个调用过程中所处的位置准备准备添加数据获取有的解析器涉及有的解析器涉及数据绑定生成数据得到处理有的处理器涉及添加数据处理视图名是否渲染等获取收获返回响应体前包装异常解析器演示代码参考收获它能够重用参数解析器返回值处理器实现组件重用它能够支持嵌套异常之演示准备代码参考包收获初始化时会解析中的方法会以类为单位在该类首次处理异常时解析此类的方法以上两种的解析结果都会缓存来避免重复解析异常处理我们知道只能处理发生在流程中的异常例如控制器内拦截器内那么如果是出现了异常如何进行处理呢在中是这么实现的因为内嵌了容器因此可以配置的错误页面与错误页面之间是通过请求转发跳转的可以在这里做手脚先通过这个后处理器配置错误页面地址默认为也可以通过进行配置当发生异常时不会走流程但会走的错误处理于是就希望转发至这个地址当然如果没有那么最终也会走到的错误处理又提供了一个它就是一个标准配置为所以处理异常的职责就又回到了异常信息由于会被放入作用域因此里也能获取到具体异常信息会由封装好通过头判断需要生成哪种的响应如果要的不是走流程如果需要走流程此时又分两种情况配置了根据状态码去找没配置或没找到用根据一个固定为的名字找到即所谓的评价一个错误处理搞得这么复杂就问恶心不演示错误页处理关键代码修改了服务器默认错误地址出错时使用请求转发方式跳转初始化前用它增强注册所有收获的错误页处理手段演示关键代码封装环境键值控制有哪些错误信息名称为的视图作为的响应结果服务器内部错误收集容器中所有对象的名字作为视图名收获中如何工作与演示本组映射器和适配器关键代码收获以开头的的名字会被当作映射路径这些本身当作要求实现接口调用模拟实现这组映射器和适配器与演示本组映射器和适配器关键代码映射条件收获通过条件映射要实现接口调用与演示本组映射器和适配器代码参考关键代码收获不会在初始化时收集映射信息需要手动收集映射路径作为静态资源调用此演示静态资源解析优化关键代码缓存优化压缩优化原始资源解析收获责任链模式体现压缩文件需要手动生成演示欢迎页关键代码收获欢迎页支持静态欢迎页与动态欢迎页映射欢迎页即只映射它内置的作用是不执行逻辑仅根据视图名找视图视图名固定为调用转发至处理又会走上面的静态资源处理流程映射器与适配器小结负责建立请求与控制器之间的映射关系与匹配与的名字匹配以开头函数式静态资源通配符之间也会有顺序问题中默认顺序如上负责实现对各种各样的的适配调用处理方法参数解析器返回值处理器体现了组合模式处理接口处理函数式接口处理接口静态资源处理这也是典型适配器模式体现处理流程当浏览器发送一个请求后请求到达服务器其处理流程是服务器提供了它使用的是标准技术路径默认映射路径为即会匹配到所有请求可作为请求的统一入口也被称之为前控制器不会匹配到其它有路径的匹配优先级也高于创建在中由这个自动配置类提供的初始化初始化时会优先到容器里寻找各种组件作为它的成员变量初始化时记录映射关系初始化时准备参数解析器返回值处理器消息转换器初始化时准备参数解析器返回值处理器消息转换器会利用查找控制器方法例如根据路径找到对应的控制器方法控制器方法会被封装为对象并结合匹配到的拦截器一起返回给和拦截器合在一起称为调用链对象接下来会调用拦截器的方法调用方法准备数据绑定工厂模型工厂将完善为全局增强点补充模型数据全局增强点补充自定义类型转换器使用准备参数全局增强点增强调用使用处理返回值全局增强点增强根据获取如果返回的为不走第步视图解析及渲染流程例如有的返回值处理器调用了来将结果转换为这时就为如果返回的不为会在第步走视图解析及渲染流程调用拦截器的方法处理异常或视图渲染如果出现异常走处理异常流程全局增强点异常处理正常走视图解析及渲染流程调用拦截器的方法骨架项目如果是环境用以下命令即可获取的骨架也可以使用等工具实现若想获取更多用法请参考项目步骤创建模块区别在于打包方式选择接下来勾选支持步骤编写控制器进入了控制器步骤编写视图新建目录和一个文件注意文件名与控制器方法返回的视图逻辑名一致步骤配置视图路径打开文件将来控制器方法返回值即为视图完整路径测试如果用插件或方法测试必须添加如下依赖因为此时用的还是内嵌而内嵌默认不带用来解析也可以使用配置来测试此时用的是外置骨架生成的代码中多了一个它的作用就是配置外置使用的在外置启动后去调用它创建和运行启示对于项目若要支持也可以在加入依赖的前提下把文件置入启动过程阶段一构造记录源推断应用类型记录初始化器记录监听器推断主启动类阶段二执行方法得到名字取得不好实际是事件发布器发布事件封装启动准备添加命令行参数处理发布已准备事件通过进行后处理由解析绑定到对象打印创建容器准备容器发布已初始化事件加载定义发布事件容器发布事件执行发布事件这其中有异常发布事件带的有独立的示例演示启动过程对应构造对应第步并演示个事件对应第到步收获构造方法中所做的操作可以有多种源用来加载定义应用类型推断添加容器初始化器添加监听器演示主类推断如何读取中的配置从配置中获取重要的事件发布器容器的创建初始化器增强加载定义等的作用环境对象命令行规范环境键名称后处理增强由通过监听事件来调用绑定前缀的至内嵌容器基本结构协议端口虚拟主机应用可以设置虚拟路径即起始路径项目磁盘路径即第三方包应用演示内嵌容器关键代码创建对象创建项目文件夹即文件夹创建项目在中称为编程添加启动创建连接器设置监听端口演示集成容器关键代码编程添加通过添加等自动配置是利用了自动配置类来简化了相关配置自动配置类为可以通过禁用自动配置自动配置的本质是通过来开启了自动代理如果在引导类上自己添加了那么以自己添加的为准的本质是向容器中添加了这个后处理器它能够找到容器中所有切面并为匹配切点的目标类创建代理创建代理的工作一般是在的初始化阶段完成的对应的自动配置类为它内部采用了条件装配通过检查容器的以及类路径下的来决定该是否生效简单说明一下支持两大类数据源内嵌数据库连接池非内嵌数据库连接池又支持如下数据源提供的提供的提供的提供的如果知道数据源的实现类类型即指定了理论上可以支持所有数据源但这样做的一个最大问题是无法订制每种数据源的详细配置如最大最小连接数等自动配置类为它主要配置了两个核心对象用来创建的实现此实现会与当前线程绑定用的方式扫描所有标注了注解的接口用来确定扫描的包还有一个相关的它会读取配置文件中带前缀的配置项进行定制配置注解的作用与类似会注册有如下区别扫描具体包当然也可以配置关注哪个注解如果不指定扫描具体包则会把引导类范围内所有接口当做接口关注的是所有标注注解的接口会忽略掉非标注的接口这里有同学有疑问之前介绍的都是将具体类交给管理怎么到了这儿接口就可以被管理呢其实并非将接口交给管理而是每个接口会对应一个是后者被所管理接口只是作为的一个属性来配置事务自动配置类有两个前者配置了用来执行事务的提交回滚操作后者功能上对标包含以下三个事务切面类包含通知和切点事务通知类由它在目标方法调用前后加入事务操作会解析及事务属性也包含了切点功能如果自己配置了或是在引导类加了则以自己配置的为准提供提供提供配置的各项组件提供的见过的有多项多项提供的有它提供了该用来解析格式的数据请求参数如果有中文无需特殊设置这是因为已经配置了对应配置默认就是当然它只影响非格式的数据演示自动配置类原理关键代码假设已有第三方的两个自动配置类第三方的配置类第三方的配置类提供一个配置文件为导入器类名值为多个自动配置类名用逗号分隔注意上述配置文件中与为简洁均省略了包名自己测试时请将包名根据情况补全引入自动配置本项目的配置类该方法从读取自动配置类名返回的即为要导入的配置类收获自动配置类本质上就是一个配置类而已只是用管理与应用配置类解耦打头的注解本质是利用了配合即可实现导入方法的返回值即为要导入的配置类名的导入会在最后执行为的是让其它配置优先解析条件装配底层条件装配的底层是本质上是与这两个注解引入自动配置类时期望满足一定条件才能被管理不满足则不管理怎么做呢比如条件是类路径下必须有这个怎么做呢首先编写条件判断类它实现接口编写条件判断逻辑如果存在依赖条件成立其次在要导入的自动配置类上添加将来此类被导入时就会做条件检查第三方的配置类加入条件分别测试加入和去除依赖观察是否存在于容器收获学习一种特殊的其它演示代码参考包收获它的作用是用制造创建过程较为复杂的产品如但已具备等价功能使用上较为古怪一不留神就会用错被创建的产品会认为创建依赖注入接口回调前初始化这些都是的职责这些流程都不会走唯有后初始化的流程会走也就是产品可以被代理增强单例的产品不会存储于的成员中而是另一个成员中按名字去获取时拿到的是产品对象名字前面加获取的是工厂对象原理真实项目中只需要加入以下依赖即可演示代码参考包收获在编译时就根据生成文件扫描时如果发现存在以它为准加载否则会遍历包下所有资源包括内的解决的问题在编译期就找到组件节省运行期间扫描的时间代理进一步理解演示代理代码参考包收获代理的设计特点依赖注入和初始化影响的是原始对象因此不能用代理与目标是两个对象二者成员变量并不共用数据方法方法方法均无法增强进一步理解代理增强基于方法重写装配底层按类型装配的步骤查看需要的类型是否为是则进行封装非延迟否则向下走查看需要的类型是否为或是则进行封装延迟否则向下走查看需要的类型成员或参数上是否用修饰是则返回代理否则向下走解析的值如果需要的值是字符串先解析再解析不是字符串需要用转换看需要的类型是否为是则按集合处理否则向下走在的中找有没有类型合适的对象注入没有向下走在及父工厂中找类型匹配的进行筛选筛选时会考虑及泛型结果个数为抛出异常如果结果再根据进行筛选如果结果仍再根据成员名或变量名进行筛选结果仍抛出异常演示装配过程代码参考包收获作用之一获取的值了解对应的解析器了解对应的解析器的一项体现装配底层演示装配过程代码参考包收获本质上是根据成员变量或方法参数的类型进行装配如果待装配类型是需要根据泛型找到再封装为对象装配如果待装配的类型是需要根据泛型创建对象装配此方法可以延迟的获取如果待装配的成员变量或方法参数上用标注会创建代理对象装配此方法可以延迟真实的获取被装配的代理不作为如果待装配类型是数组需要获取数组元素类型根据此类型找到多个进行装配如果待装配类型是或其子接口需要获取泛型根据此类型找到多个如果待装配类型是等特殊类型会在的成员按类型查找装配是集合是特殊类型是其对应对象不能直接根据进行查找而是用逐一尝试右边类型是否可以被赋值给左边的类型如果待装配类型有泛型参数需要利用按泛型参数类型筛选如果待装配类型有需要利用按注解提供的名称筛选有标注的或的处理与成员变量名或方法参数名同名的处理事件监听器演示事件监听器代码参考包收获事件监听器的两种方式实现接口根据接口泛型确定事件类型标注监听方法根据监听器方法参数确定事件类型解析时机在所有单例初始化完成后解析每个单例事件发布器演示事件发布器代码参考包收获事件发布器模拟实现负责收集容器中的监听器监听器会统一转换为对象以支持判断事件类型遍历监听器集合发布事件发布前先通过判断支持该事件类型才发事件可以利用线程池进行异步发事件优化如果发送的事件对象不是类型会把它包装为并用泛型技术解析事件对象的原始类型视频中未讲解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-13 11:35:48',
  postMainColor: '#cffcff',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/html/css/summ.css"><link rel="stylesheet" href="/html/css/azy.css"><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Pei</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="fa-solid fa-music faa-tada"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lightbulb"></use></svg><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://upyun.goku.top/blog/wxpay.jpeg!cover" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://upyun.goku.top/blog/wxpay.jpeg!cover"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://upyun.goku.top/blog/alipay.jpeg!cover" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://upyun.goku.top/blog/alipay.jpeg!cover"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 1.05rem;">AI<sup>1</sup></a><a href="/tags/GPT/" style="font-size: 1.05rem;">GPT<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/IntelliJ-IDEA/" style="font-size: 1.05rem;">IntelliJ IDEA<sup>1</sup></a><a href="/tags/JVM/" style="font-size: 1.05rem;">JVM<sup>2</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>16</sup></a><a href="/tags/Netty/" style="font-size: 1.05rem;">Netty<sup>4</sup></a><a href="/tags/Python/" style="font-size: 1.05rem;">Python<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>3</sup></a><a href="/tags/TVBox/" style="font-size: 1.05rem;">TVBox<sup>1</sup></a><a href="/tags/blog/" style="font-size: 1.05rem;">blog<sup>3</sup></a><a href="/tags/docker/" style="font-size: 1.05rem;">docker<sup>2</sup></a><a href="/tags/frp/" style="font-size: 1.05rem;">frp<sup>1</sup></a><a href="/tags/ios/" style="font-size: 1.05rem;">ios<sup>2</sup></a><a href="/tags/macos/" style="font-size: 1.05rem;">macos<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>2</sup></a><a href="/tags/nginx/" style="font-size: 1.05rem;">nginx<sup>1</sup></a><a href="/tags/redis/" style="font-size: 1.05rem;">redis<sup>2</sup></a><a href="/tags/trollstore/" style="font-size: 1.05rem;">trollstore<sup>1</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" style="font-size: 1.05rem;">内网穿透<sup>1</sup></a><a href="/tags/%E5%A5%87%E6%80%AA%E7%9A%84%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">奇怪的知识<sup>2</sup></a><a href="/tags/%E5%A8%B1%E4%B9%90/" style="font-size: 1.05rem;">娱乐<sup>2</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">学习<sup>2</sup></a><a href="/tags/%E5%AE%89%E5%8D%93/" style="font-size: 1.05rem;">安卓<sup>2</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">工具<sup>2</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" style="font-size: 1.05rem;">开发问题记录<sup>4</sup></a><a href="/tags/%E5%BD%B1%E9%9F%B3/" style="font-size: 1.05rem;">影音<sup>1</sup></a><a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 1.05rem;">生活<sup>4</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>3</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 1.05rem;">项目<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring/" itemprop="url">Spring</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Java</span></a><a class="article-meta__tags" href="/tags/Spring/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Spring</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Spring高级49讲原笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2022-03-28T12:11:10.000Z" title="发表于 2022-03-28 20:11:10">2022-03-28</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-12-13T03:35:48.277Z" title="更新于 2024-12-13 11:35:48">2024-12-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为杭州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>杭州</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://upyun.goku.top/blog/spring.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.goku.top/posts/52604.html"><header><a class="post-meta-categories" href="/categories/Spring/" itemprop="url">Spring</a><a href="/tags/Java/" tabindex="-1" itemprop="url">Java</a><a href="/tags/Spring/" tabindex="-1" itemprop="url">Spring</a><h1 id="CrawlerTitle" itemprop="name headline">Spring高级49讲原笔记</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Pei</span><time itemprop="dateCreated datePublished" datetime="2022-03-28T12:11:10.000Z" title="发表于 2022-03-28 20:11:10">2022-03-28</time><time itemprop="dateCreated datePublished" datetime="2024-12-13T03:35:48.277Z" title="更新于 2024-12-13 11:35:48">2024-12-13</time></header><h2 id="容器与-bean"><a href="#容器与-bean" class="headerlink" title="容器与 bean"></a>容器与 bean</h2><h3 id="1-容器接口"><a href="#1-容器接口" class="headerlink" title="1) 容器接口"></a>1) 容器接口</h3><ul>
<li><p>BeanFactory 接口，典型功能有：</p>
<ul>
<li>getBean</li>
</ul>
</li>
<li><p>ApplicationContext 接口，是 BeanFactory 的子接口。它扩展了 BeanFactory 接口的功能，如：</p>
<ul>
<li>国际化</li>
<li>通配符方式获取一组 Resource 资源</li>
<li>整合 Environment 环境（能通过它获取各种来源的配置信息）</li>
<li>事件发布与监听，实现组件之间的解耦</li>
</ul>
</li>
</ul>
<p>可以看到，我们课上讲的，都是 BeanFactory 提供的基本功能，ApplicationContext 中的扩展功能都没有用到。</p>
<h4 id="演示1-BeanFactory-与-ApplicationContext-的区别"><a href="#演示1-BeanFactory-与-ApplicationContext-的区别" class="headerlink" title="演示1 - BeanFactory 与 ApplicationContext 的区别"></a>演示1 - BeanFactory 与 ApplicationContext 的区别</h4><h5 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a01</strong> 包</p>
<h4 id="收获💡"><a href="#收获💡" class="headerlink" title="收获💡"></a>收获💡</h4><p>通过这个示例结合 debug 查看 ApplicationContext 对象的内部结构，学到：</p>
<ol>
<li><p>到底什么是 BeanFactory</p>
<ul>
<li>它是 ApplicationContext 的父接口</li>
<li>它才是 Spring 的核心容器, 主要的 ApplicationContext 实现都【组合】了它的功能，【组合】是指 ApplicationContext 的一个重要成员变量就是 BeanFactory</li>
</ul>
</li>
<li><p>BeanFactory 能干点啥</p>
<ul>
<li>表面上只有 getBean</li>
<li>实际上控制反转、基本的依赖注入、直至 Bean 的生命周期的各种功能，都由它的实现类提供</li>
<li>例子中通过反射查看了它的成员变量 singletonObjects，内部包含了所有的单例 bean</li>
</ul>
</li>
<li><p>ApplicationContext 比 BeanFactory 多点啥</p>
<ul>
<li>ApplicationContext 组合并扩展了 BeanFactory 的功能</li>
<li>国际化、通配符方式获取一组 Resource 资源、整合 Environment 环境、事件发布与监听</li>
<li>新学一种代码之间解耦途径，事件解耦</li>
</ul>
</li>
</ol>
<p>建议练习：完成用户注册与发送短信之间的解耦，用事件方式、和 AOP 方式分别实现</p>
<blockquote>
<p><em><strong>注意</strong></em></p>
<ul>
<li>如果 jdk &gt; 8, 运行时请添加 –add-opens java.base&#x2F;java.lang&#x3D;ALL-UNNAMED，这是因为这些版本的 jdk 默认不允许跨 module 反射</li>
<li>事件发布还可以异步，这个视频中没有展示，请自行查阅 @EnableAsync，@Async 的用法</li>
</ul>
</blockquote>
<h4 id="演示2-国际化"><a href="#演示2-国际化" class="headerlink" title="演示2 - 国际化"></a>演示2 - 国际化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMessageSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"></span><br><span class="line">        context.registerBean(<span class="string">&quot;messageSource&quot;</span>, MessageSource.class, () -&gt; &#123;</span><br><span class="line">            <span class="type">ResourceBundleMessageSource</span> <span class="variable">ms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceBundleMessageSource</span>();</span><br><span class="line">            ms.setDefaultEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            ms.setBasename(<span class="string">&quot;messages&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ms;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getMessage(<span class="string">&quot;hi&quot;</span>, <span class="literal">null</span>, Locale.ENGLISH));</span><br><span class="line">        System.out.println(context.getMessage(<span class="string">&quot;hi&quot;</span>, <span class="literal">null</span>, Locale.CHINESE));</span><br><span class="line">        System.out.println(context.getMessage(<span class="string">&quot;hi&quot;</span>, <span class="literal">null</span>, Locale.JAPANESE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>国际化文件均在 src&#x2F;resources 目录下</p>
<p>messages.properties（空）</p>
<p>messages_en.properties</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hi</span>=<span class="string">Hello</span></span><br></pre></td></tr></table></figure>

<p>messages_ja.properties</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hi</span>=<span class="string">こんにちは</span></span><br></pre></td></tr></table></figure>

<p>messages_zh.properties</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hi</span>=<span class="string">你好</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><em><strong>注意</strong></em></p>
<ul>
<li>ApplicationContext 中 MessageSource bean 的名字固定为 messageSource</li>
<li>使用 SpringBoot 时，国际化文件名固定为 messages</li>
<li>空的 messages.properties 也必须存在</li>
</ul>
</blockquote>
<h3 id="2-容器实现"><a href="#2-容器实现" class="headerlink" title="2) 容器实现"></a>2) 容器实现</h3><p>Spring 的发展历史较为悠久，因此很多资料还在讲解它较旧的实现，这里出于怀旧的原因，把它们都列出来，供大家参考</p>
<ul>
<li>DefaultListableBeanFactory，是 BeanFactory 最重要的实现，像<strong>控制反转</strong>和<strong>依赖注入</strong>功能，都是它来实现</li>
<li>ClassPathXmlApplicationContext，从类路径查找 XML 配置文件，创建容器（旧）</li>
<li>FileSystemXmlApplicationContext，从磁盘路径查找 XML 配置文件，创建容器（旧）</li>
<li>XmlWebApplicationContext，传统 SSM 整合时，基于 XML 配置文件的容器（旧）</li>
<li>AnnotationConfigWebApplicationContext，传统 SSM 整合时，基于 java 配置类的容器（旧）</li>
<li>AnnotationConfigApplicationContext，Spring boot 中非 web 环境容器（新）</li>
<li>AnnotationConfigServletWebServerApplicationContext，Spring boot 中 servlet web 环境容器（新）</li>
<li>AnnotationConfigReactiveWebServerApplicationContext，Spring boot 中 reactive web 环境容器（新）</li>
</ul>
<p>另外要注意的是，后面这些带有 ApplicationContext 的类都是 ApplicationContext 接口的实现，但它们是<strong>组合</strong>了 DefaultListableBeanFactory 的功能，并非继承而来</p>
<h4 id="演示1-DefaultListableBeanFactory"><a href="#演示1-DefaultListableBeanFactory" class="headerlink" title="演示1 - DefaultListableBeanFactory"></a>演示1 - DefaultListableBeanFactory</h4><h5 id="代码参考-1"><a href="#代码参考-1" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a02.TestBeanFactory</strong></p>
<h4 id="收获💡-1"><a href="#收获💡-1" class="headerlink" title="收获💡"></a>收获💡</h4><ul>
<li>beanFactory 可以通过 registerBeanDefinition 注册一个 bean definition 对象<ul>
<li>我们平时使用的配置类、xml、组件扫描等方式都是生成 bean definition 对象注册到 beanFactory 当中</li>
<li>bean definition 描述了这个 bean 的创建蓝图：scope 是什么、用构造还是工厂创建、初始化销毁方法是什么，等等</li>
</ul>
</li>
<li>beanFactory 需要手动调用 beanFactory 后处理器对它做增强<ul>
<li>例如通过解析 @Bean、@ComponentScan 等注解，来补充一些 bean definition</li>
</ul>
</li>
<li>beanFactory 需要手动添加 bean 后处理器，以便对后续 bean 的创建过程提供增强<ul>
<li>例如 @Autowired，@Resource 等注解的解析都是 bean 后处理器完成的</li>
<li>bean 后处理的添加顺序会对解析结果有影响，见视频中同时加 @Autowired，@Resource 的例子</li>
</ul>
</li>
<li>beanFactory 需要手动调用方法来初始化单例</li>
<li>beanFactory 需要额外设置才能解析 ${} 与 #{}</li>
</ul>
<h4 id="演示2-常见-ApplicationContext-实现"><a href="#演示2-常见-ApplicationContext-实现" class="headerlink" title="演示2 - 常见 ApplicationContext 实现"></a>演示2 - 常见 ApplicationContext 实现</h4><h5 id="代码参考-2"><a href="#代码参考-2" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a02.A02</strong></p>
<h4 id="收获💡-2"><a href="#收获💡-2" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>常见的 ApplicationContext 容器实现</li>
<li>内嵌容器、DispatcherServlet 的创建方法、作用</li>
</ol>
<h3 id="3-Bean-的生命周期"><a href="#3-Bean-的生命周期" class="headerlink" title="3) Bean 的生命周期"></a>3) Bean 的生命周期</h3><p>一个受 Spring 管理的 bean，生命周期主要阶段有</p>
<ol>
<li>创建：根据 bean 的构造方法或者工厂方法来创建 bean 实例对象</li>
<li>依赖注入：根据 @Autowired，@Value 或其它一些手段，为 bean 的成员变量填充值、建立关系</li>
<li>初始化：回调各种 Aware 接口，调用对象的各种初始化方法</li>
<li>销毁：在容器关闭时，会销毁所有单例对象（即调用它们的销毁方法）<ul>
<li>prototype 对象也能够销毁，不过需要容器这边主动调用</li>
</ul>
</li>
</ol>
<p>一些资料会提到，生命周期中还有一类 bean 后处理器：BeanPostProcessor，会在 bean 的初始化的前后，提供一些扩展逻辑。但这种说法是不完整的，见下面的演示1</p>
<h4 id="演示1-bean-生命周期"><a href="#演示1-bean-生命周期" class="headerlink" title="演示1 - bean 生命周期"></a>演示1 - bean 生命周期</h4><h5 id="代码参考-3"><a href="#代码参考-3" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a03</strong> 包</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  graph LR

创建 --&gt; 依赖注入
依赖注入 --&gt; 初始化
初始化 --&gt; 可用
可用 --&gt; 销毁
  </pre></div>

<p>创建前后的增强</p>
<ul>
<li>postProcessBeforeInstantiation<ul>
<li>这里返回的对象若不为 null 会替换掉原本的 bean，并且仅会走 postProcessAfterInitialization 流程</li>
</ul>
</li>
<li>postProcessAfterInstantiation<ul>
<li>这里如果返回 false 会跳过依赖注入阶段</li>
</ul>
</li>
</ul>
<p>依赖注入前的增强</p>
<ul>
<li>postProcessProperties<ul>
<li>如 @Autowired、@Value、@Resource</li>
</ul>
</li>
</ul>
<p>初始化前后的增强</p>
<ul>
<li>postProcessBeforeInitialization<ul>
<li>这里返回的对象会替换掉原本的 bean</li>
<li>如 @PostConstruct、@ConfigurationProperties</li>
</ul>
</li>
<li>postProcessAfterInitialization<ul>
<li>这里返回的对象会替换掉原本的 bean</li>
<li>如代理增强</li>
</ul>
</li>
</ul>
<p>销毁之前的增强</p>
<ul>
<li>postProcessBeforeDestruction<ul>
<li>如 @PreDestroy</li>
</ul>
</li>
</ul>
<h4 id="收获💡-3"><a href="#收获💡-3" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>Spring bean 生命周期各个阶段</li>
<li>模板设计模式, 指大流程已经固定好了, 通过接口回调（bean 后处理器）在一些关键点前后提供扩展</li>
</ol>
<h4 id="演示2-模板方法设计模式"><a href="#演示2-模板方法设计模式" class="headerlink" title="演示2 - 模板方法设计模式"></a>演示2 - 模板方法设计模式</h4><h5 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethodTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBeanFactory</span>();</span><br><span class="line">        beanFactory.addBeanPostProcessor(bean -&gt; System.out.println(<span class="string">&quot;解析 @Autowired&quot;</span>));</span><br><span class="line">        beanFactory.addBeanPostProcessor(bean -&gt; System.out.println(<span class="string">&quot;解析 @Resource&quot;</span>));</span><br><span class="line">        beanFactory.getBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法  Template Method Pattern</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;构造 &quot;</span> + bean);</span><br><span class="line">            System.out.println(<span class="string">&quot;依赖注入 &quot;</span> + bean); <span class="comment">// @Autowired, @Resource</span></span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor processor : processors) &#123;</span><br><span class="line">                processor.inject(bean);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;初始化 &quot;</span> + bean);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;BeanPostProcessor&gt; processors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeanPostProcessor</span><span class="params">(BeanPostProcessor processor)</span> &#123;</span><br><span class="line">            processors.add(processor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object bean)</span>; <span class="comment">// 对依赖注入阶段的扩展</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="演示3-bean-后处理器排序"><a href="#演示3-bean-后处理器排序" class="headerlink" title="演示3 - bean 后处理器排序"></a>演示3 - bean 后处理器排序</h4><h5 id="代码参考-4"><a href="#代码参考-4" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a03.TestProcessOrder</strong></p>
<h4 id="收获💡-4"><a href="#收获💡-4" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>实现了 PriorityOrdered 接口的优先级最高</li>
<li>实现了 Ordered 接口与加了 @Order 注解的平级, 按数字升序</li>
<li>其它的排在最后</li>
</ol>
<h3 id="4-Bean-后处理器"><a href="#4-Bean-后处理器" class="headerlink" title="4) Bean 后处理器"></a>4) Bean 后处理器</h3><h4 id="演示1-后处理器作用"><a href="#演示1-后处理器作用" class="headerlink" title="演示1 - 后处理器作用"></a>演示1 - 后处理器作用</h4><h5 id="代码参考-5"><a href="#代码参考-5" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a04</strong> 包</p>
<h4 id="收获💡-5"><a href="#收获💡-5" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>@Autowired 等注解的解析属于 bean 生命周期阶段（依赖注入, 初始化）的扩展功能，这些扩展功能由 bean 后处理器来完成</li>
<li>每个后处理器各自增强什么功能<ul>
<li>AutowiredAnnotationBeanPostProcessor 解析 @Autowired 与 @Value</li>
<li>CommonAnnotationBeanPostProcessor 解析 @Resource、@PostConstruct、@PreDestroy</li>
<li>ConfigurationPropertiesBindingPostProcessor 解析 @ConfigurationProperties</li>
</ul>
</li>
<li>另外 ContextAnnotationAutowireCandidateResolver 负责获取 @Value 的值，解析 @Qualifier、泛型、@Lazy 等</li>
</ol>
<h4 id="演示2-Autowired-bean-后处理器运行分析"><a href="#演示2-Autowired-bean-后处理器运行分析" class="headerlink" title="演示2 - @Autowired bean 后处理器运行分析"></a>演示2 - @Autowired bean 后处理器运行分析</h4><h5 id="代码参考-6"><a href="#代码参考-6" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a04.DigInAutowired</strong></p>
<h4 id="收获💡-6"><a href="#收获💡-6" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata 用来获取某个 bean 上加了 @Value @Autowired 的成员变量，方法参数的信息，表示为 InjectionMetadata</li>
<li>InjectionMetadata 可以完成依赖注入</li>
<li>InjectionMetadata 内部根据成员变量，方法参数封装为 DependencyDescriptor 类型</li>
<li>有了 DependencyDescriptor，就可以利用 beanFactory.doResolveDependency 方法进行基于类型的查找</li>
</ol>
<h3 id="5-BeanFactory-后处理器"><a href="#5-BeanFactory-后处理器" class="headerlink" title="5) BeanFactory 后处理器"></a>5) BeanFactory 后处理器</h3><h4 id="演示1-BeanFactory-后处理器的作用"><a href="#演示1-BeanFactory-后处理器的作用" class="headerlink" title="演示1 - BeanFactory 后处理器的作用"></a>演示1 - BeanFactory 后处理器的作用</h4><h5 id="代码参考-7"><a href="#代码参考-7" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a05</strong> 包</p>
<ul>
<li>ConfigurationClassPostProcessor 可以解析<ul>
<li>@ComponentScan</li>
<li>@Bean</li>
<li>@Import</li>
<li>@ImportResource</li>
</ul>
</li>
<li>MapperScannerConfigurer 可以解析<ul>
<li>Mapper 接口</li>
</ul>
</li>
</ul>
<h4 id="收获💡-7"><a href="#收获💡-7" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>@ComponentScan, @Bean, @Mapper 等注解的解析属于核心容器（即 BeanFactory）的扩展功能</li>
<li>这些扩展功能由不同的 BeanFactory 后处理器来完成，其实主要就是补充了一些 bean 定义</li>
</ol>
<h4 id="演示2-模拟解析-ComponentScan"><a href="#演示2-模拟解析-ComponentScan" class="headerlink" title="演示2 - 模拟解析 @ComponentScan"></a>演示2 - 模拟解析 @ComponentScan</h4><h5 id="代码参考-8"><a href="#代码参考-8" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a05.ComponentScanPostProcessor</strong></p>
<h4 id="收获💡-8"><a href="#收获💡-8" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>Spring 操作元数据的工具类 CachingMetadataReaderFactory</li>
<li>通过注解元数据（AnnotationMetadata）获取直接或间接标注的注解信息</li>
<li>通过类元数据（ClassMetadata）获取类名，AnnotationBeanNameGenerator 生成 bean 名</li>
<li>解析元数据是基于 ASM 技术</li>
</ol>
<h4 id="演示3-模拟解析-Bean"><a href="#演示3-模拟解析-Bean" class="headerlink" title="演示3 - 模拟解析 @Bean"></a>演示3 - 模拟解析 @Bean</h4><h5 id="代码参考-9"><a href="#代码参考-9" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a05.AtBeanPostProcessor</strong></p>
<h4 id="收获💡-9"><a href="#收获💡-9" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>进一步熟悉注解元数据（AnnotationMetadata）获取方法上注解信息</li>
</ol>
<h4 id="演示4-模拟解析-Mapper-接口"><a href="#演示4-模拟解析-Mapper-接口" class="headerlink" title="演示4 - 模拟解析 Mapper 接口"></a>演示4 - 模拟解析 Mapper 接口</h4><h5 id="代码参考-10"><a href="#代码参考-10" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a05.MapperPostProcessor</strong></p>
<h4 id="收获💡-10"><a href="#收获💡-10" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>Mapper 接口被 Spring 管理的本质：实际是被作为 MapperFactoryBean 注册到容器中</li>
<li>Spring 的诡异做法，根据接口生成的 BeanDefinition 仅为根据接口名生成 bean 名</li>
</ol>
<h3 id="6-Aware-接口"><a href="#6-Aware-接口" class="headerlink" title="6) Aware 接口"></a>6) Aware 接口</h3><h4 id="演示-Aware-接口及-InitializingBean-接口"><a href="#演示-Aware-接口及-InitializingBean-接口" class="headerlink" title="演示 - Aware 接口及 InitializingBean 接口"></a>演示 - Aware 接口及 InitializingBean 接口</h4><h5 id="代码参考-11"><a href="#代码参考-11" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a06</strong> 包</p>
<h4 id="收获💡-11"><a href="#收获💡-11" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>Aware 接口提供了一种【内置】 的注入手段，例如<ul>
<li>BeanNameAware 注入 bean 的名字</li>
<li>BeanFactoryAware 注入 BeanFactory 容器</li>
<li>ApplicationContextAware 注入 ApplicationContext 容器</li>
<li>EmbeddedValueResolverAware 注入 ${} 解析器</li>
</ul>
</li>
<li>InitializingBean 接口提供了一种【内置】的初始化手段</li>
<li>对比<ul>
<li>内置的注入和初始化不受扩展功能的影响，总会被执行</li>
<li>而扩展功能受某些情况影响可能会失效</li>
<li>因此 Spring 框架内部的类常用内置注入和初始化</li>
</ul>
</li>
</ol>
<h4 id="配置类-Autowired-失效分析"><a href="#配置类-Autowired-失效分析" class="headerlink" title="配置类 @Autowired 失效分析"></a>配置类 @Autowired 失效分析</h4><p>Java 配置类不包含 BeanFactoryPostProcessor 的情况</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  sequenceDiagram
participant ac as ApplicationContext
participant bfpp as BeanFactoryPostProcessor
participant bpp as BeanPostProcessor
participant config as Java配置类
ac -&gt;&gt; bfpp : 1. 执行 BeanFactoryPostProcessor
ac -&gt;&gt; bpp : 2. 注册 BeanPostProcessor
ac -&gt;&gt; +config : 3. 创建和初始化
bpp -&gt;&gt; config : 3.1 依赖注入扩展(如 @Value 和 @Autowired)
bpp -&gt;&gt; config : 3.2 初始化扩展(如 @PostConstruct)
ac -&gt;&gt; config : 3.3 执行 Aware 及 InitializingBean
config --&gt;&gt; -ac : 3.4 创建成功
  </pre></div>

<p>Java 配置类包含 BeanFactoryPostProcessor 的情况，因此要创建其中的 BeanFactoryPostProcessor 必须提前创建 Java 配置类，而此时的 BeanPostProcessor 还未准备好，导致 @Autowired 等注解失效</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  sequenceDiagram
participant ac as ApplicationContext
participant bfpp as BeanFactoryPostProcessor
participant bpp as BeanPostProcessor
participant config as Java配置类
ac -&gt;&gt; +config : 3. 创建和初始化
ac -&gt;&gt; config : 3.1 执行 Aware 及 InitializingBean
config --&gt;&gt; -ac : 3.2 创建成功

ac -&gt;&gt; bfpp : 1. 执行 BeanFactoryPostProcessor
ac -&gt;&gt; bpp : 2. 注册 BeanPostProcessor

  </pre></div>

<p>对应代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(MyConfig1.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;注入 ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//  ⬅️ 注释或添加 beanFactory 后处理器对应上方两种情况</span></span><br><span class="line">    <span class="keyword">public</span> BeanFactoryPostProcessor <span class="title function_">processor1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行 processor1&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em><strong>注意</strong></em></p>
<p>解决方法：</p>
<ul>
<li>用内置依赖注入和初始化取代扩展依赖注入和初始化</li>
<li>用静态工厂方法代替实例工厂方法，避免工厂对象提前被创建</li>
</ul>
</blockquote>
<h3 id="7-初始化与销毁"><a href="#7-初始化与销毁" class="headerlink" title="7) 初始化与销毁"></a>7) 初始化与销毁</h3><h4 id="演示-初始化销毁顺序"><a href="#演示-初始化销毁顺序" class="headerlink" title="演示 - 初始化销毁顺序"></a>演示 - 初始化销毁顺序</h4><h5 id="代码参考-12"><a href="#代码参考-12" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a07</strong> 包</p>
<h4 id="收获💡-12"><a href="#收获💡-12" class="headerlink" title="收获💡"></a>收获💡</h4><p>Spring 提供了多种初始化手段，除了课堂上讲的 @PostConstruct，@Bean(initMethod) 之外，还可以实现 InitializingBean 接口来进行初始化，如果同一个 bean 用了以上手段声明了 3 个初始化方法，那么它们的执行顺序是</p>
<ol>
<li>@PostConstruct 标注的初始化方法</li>
<li>InitializingBean 接口的初始化方法</li>
<li>@Bean(initMethod) 指定的初始化方法</li>
</ol>
<p>与初始化类似，Spring 也提供了多种销毁手段，执行顺序为</p>
<ol>
<li>@PreDestroy 标注的销毁方法</li>
<li>DisposableBean 接口的销毁方法</li>
<li>@Bean(destroyMethod) 指定的销毁方法</li>
</ol>
<h3 id="8-Scope"><a href="#8-Scope" class="headerlink" title="8) Scope"></a>8) Scope</h3><p>在当前版本的 Spring 和 Spring Boot 程序中，支持五种 Scope</p>
<ul>
<li>singleton，容器启动时创建（未设置延迟），容器关闭时销毁</li>
<li>prototype，每次使用时创建，不会自动销毁，需要调用 DefaultListableBeanFactory.destroyBean(bean) 销毁</li>
<li>request，每次请求用到此 bean 时创建，请求结束时销毁</li>
<li>session，每个会话用到此 bean 时创建，会话结束时销毁</li>
<li>application，web 容器用到此 bean 时创建，容器停止时销毁</li>
</ul>
<p>有些文章提到有 globalSession 这一 Scope，也是陈旧的说法，目前 Spring 中已废弃</p>
<p>但要注意，如果在 singleton 注入其它 scope 都会有问题，解决方法有</p>
<ul>
<li>@Lazy</li>
<li>@Scope(proxyMode &#x3D; ScopedProxyMode.TARGET_CLASS)</li>
<li>ObjectFactory</li>
<li>ApplicationContext.getBean</li>
</ul>
<h4 id="演示1-request-session-application-作用域"><a href="#演示1-request-session-application-作用域" class="headerlink" title="演示1 - request, session, application 作用域"></a>演示1 - request, session, application 作用域</h4><h5 id="代码参考-13"><a href="#代码参考-13" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a08</strong> 包</p>
<ul>
<li>打开不同的浏览器, 刷新 <a target="_blank" rel="noopener" href="http://localhost:8080/test">http://localhost:8080/test</a> 即可查看效果</li>
<li>如果 jdk &gt; 8, 运行时请添加 –add-opens java.base&#x2F;java.lang&#x3D;ALL-UNNAMED</li>
</ul>
<h4 id="收获💡-13"><a href="#收获💡-13" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>有几种 scope</li>
<li>在 singleton 中使用其它几种 scope 的方法</li>
<li>其它 scope 的销毁时机<ul>
<li>可以将通过 server.servlet.session.timeout&#x3D;30s 观察 session bean 的销毁</li>
<li>ServletContextScope 销毁机制疑似实现有误</li>
</ul>
</li>
</ol>
<h4 id="分析-singleton-注入其它-scope-失效"><a href="#分析-singleton-注入其它-scope-失效" class="headerlink" title="分析 - singleton 注入其它 scope 失效"></a>分析 - singleton 注入其它 scope 失效</h4><p>以单例注入多例为例</p>
<p>有一个单例对象 E</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(E.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> F f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">E</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;E()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setF</span><span class="params">(F f)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.f = f;</span><br><span class="line">        log.info(<span class="string">&quot;setF(F f) &#123;&#125;&quot;</span>, f.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> F <span class="title function_">getF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注入的对象 F 期望是多例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(F.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">F</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;F()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> context.getBean(E.class);</span><br><span class="line"><span class="type">F</span> <span class="variable">f1</span> <span class="operator">=</span> e.getF();</span><br><span class="line"><span class="type">F</span> <span class="variable">f2</span> <span class="operator">=</span> e.getF();</span><br><span class="line">System.out.println(f1);</span><br><span class="line">System.out.println(f2);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.itheima.demo.cycle.F@6622fc65</span><br><span class="line">com.itheima.demo.cycle.F@6622fc65</span><br></pre></td></tr></table></figure>

<p>发现它们是同一个对象，而不是期望的多例对象</p>
<p>对于单例对象来讲，依赖注入仅发生了一次，后续再没有用到多例的 F，因此 E 用的始终是第一次依赖注入的 F</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  graph LR

e1(e 创建)
e2(e set 注入 f)

f1(f 创建)

e1--&gt;f1--&gt;e2

  </pre></div>

<p>解决</p>
<ul>
<li>仍然使用 @Lazy 生成代理</li>
<li>代理对象虽然还是同一个，但当每次<strong>使用代理对象的任意方法</strong>时，由代理创建新的 f 对象</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  graph LR

e1(e 创建)
e2(e set 注入 f代理)

f1(f 创建)
f2(f 创建)
f3(f 创建)

e1--&gt;e2
e2--使用f方法--&gt;f1
e2--使用f方法--&gt;f2
e2--使用f方法--&gt;f3

  </pre></div>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setF</span><span class="params">(F f)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.f = f;</span><br><span class="line">        log.info(<span class="string">&quot;setF(F f) &#123;&#125;&quot;</span>, f.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em><strong>注意</strong></em></p>
<ul>
<li>@Lazy 加在也可以加在成员变量上，但加在 set 方法上的目的是可以观察输出，加在成员变量上就不行了</li>
<li>@Autowired 加在 set 方法的目的类似</li>
</ul>
</blockquote>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E: setF(F f) class com.itheima.demo.cycle.F$$EnhancerBySpringCGLIB$$8b54f2bc</span><br><span class="line">F: F()</span><br><span class="line">com.itheima.demo.cycle.F@3a6f2de3</span><br><span class="line">F: F()</span><br><span class="line">com.itheima.demo.cycle.F@56303b57</span><br></pre></td></tr></table></figure>

<p>从输出日志可以看到调用 setF 方法时，f 对象的类型是代理类型</p>
<h4 id="演示2-4种解决方法"><a href="#演示2-4种解决方法" class="headerlink" title="演示2 - 4种解决方法"></a>演示2 - 4种解决方法</h4><h5 id="代码参考-14"><a href="#代码参考-14" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a08.sub</strong> 包</p>
<ul>
<li>如果 jdk &gt; 8, 运行时请添加 –add-opens java.base&#x2F;java.lang&#x3D;ALL-UNNAMED</li>
</ul>
<h4 id="收获💡-14"><a href="#收获💡-14" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>单例注入其它 scope 的四种解决方法<ul>
<li>@Lazy</li>
<li>@Scope(value &#x3D; “prototype”, proxyMode &#x3D; ScopedProxyMode.TARGET_CLASS)</li>
<li>ObjectFactory</li>
<li>ApplicationContext</li>
</ul>
</li>
<li>解决方法虽然不同，但理念上殊途同归: 都是推迟其它 scope bean 的获取</li>
</ol>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP 底层实现方式之一是代理，由代理结合通知和目标，提供增强功能</p>
<p>除此以外，aspectj 提供了两种另外的 AOP 底层实现：</p>
<ul>
<li>第一种是通过 ajc 编译器在<strong>编译</strong> class 类文件时，就把通知的增强功能，织入到目标类的字节码中</li>
<li>第二种是通过 agent 在<strong>加载</strong>目标类时，修改目标类的字节码，织入增强功能</li>
<li>作为对比，之前学习的代理是<strong>运行</strong>时生成新的字节码</li>
</ul>
<p>简单比较的话：</p>
<ul>
<li>aspectj 在编译和加载时，修改目标字节码，性能较高</li>
<li>aspectj 因为不用代理，能突破一些技术上的限制，例如对构造、对静态方法、对 final 也能增强</li>
<li>但 aspectj 侵入性较强，且需要学习新的 aspectj 特有语法，因此没有广泛流行</li>
</ul>
<h3 id="9-AOP-实现之-ajc-编译器"><a href="#9-AOP-实现之-ajc-编译器" class="headerlink" title="9) AOP 实现之 ajc 编译器"></a>9) AOP 实现之 ajc 编译器</h3><p>代码参考项目 <strong>demo6_advanced_aspectj_01</strong></p>
<h4 id="收获💡-15"><a href="#收获💡-15" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>编译器也能修改 class 实现增强</li>
<li>编译器增强能突破代理仅能通过方法重写增强的限制：可以对构造方法、静态方法等实现增强</li>
</ol>
<blockquote>
<p><em><strong>注意</strong></em></p>
<ul>
<li>版本选择了 java 8, 因为目前的 aspectj-maven-plugin 1.14.0 最高只支持到 java 16</li>
<li>一定要用 maven 的 compile 来编译, idea 不会调用 ajc 编译器</li>
</ul>
</blockquote>
<h3 id="10-AOP-实现之-agent-类加载"><a href="#10-AOP-实现之-agent-类加载" class="headerlink" title="10) AOP 实现之 agent 类加载"></a>10) AOP 实现之 agent 类加载</h3><p>代码参考项目 <strong>demo6_advanced_aspectj_02</strong></p>
<h4 id="收获💡-16"><a href="#收获💡-16" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>类加载时可以通过 agent 修改 class 实现增强</li>
</ol>
<h3 id="11-AOP-实现之-proxy"><a href="#11-AOP-实现之-proxy" class="headerlink" title="11) AOP 实现之 proxy"></a>11) AOP 实现之 proxy</h3><h4 id="演示1-jdk-动态代理"><a href="#演示1-jdk-动态代理" class="headerlink" title="演示1 - jdk 动态代理"></a>演示1 - jdk 动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] param)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="comment">// 代理对象</span></span><br><span class="line">        <span class="type">Foo</span> <span class="variable">proxy</span> <span class="operator">=</span> (Foo) Proxy.newProxyInstance(</span><br><span class="line">                Target.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Foo.class&#125;,</span><br><span class="line">                (p, method, args) -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;proxy before...&quot;</span>);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                    System.out.println(<span class="string">&quot;proxy after...&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 调用代理</span></span><br><span class="line">        proxy.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy before...</span><br><span class="line">target foo</span><br><span class="line">proxy after...</span><br></pre></td></tr></table></figure>

<h4 id="收获💡-17"><a href="#收获💡-17" class="headerlink" title="收获💡"></a>收获💡</h4><ul>
<li>jdk 动态代理要求目标<strong>必须</strong>实现接口，生成的代理类实现相同接口，因此代理与目标之间是平级兄弟关系</li>
</ul>
<h4 id="演示2-cglib-代理"><a href="#演示2-cglib-代理" class="headerlink" title="演示2 - cglib 代理"></a>演示2 - cglib 代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] param)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="comment">// 代理对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">proxy</span> <span class="operator">=</span> (Target) Enhancer.create(Target.class, </span><br><span class="line">                (MethodInterceptor) (p, method, args, methodProxy) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;proxy before...&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invoke(target, args);</span><br><span class="line">            <span class="comment">// 另一种调用方法，不需要目标对象实例</span></span><br><span class="line"><span class="comment">//            Object result = methodProxy.invokeSuper(p, args);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;proxy after...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 调用代理</span></span><br><span class="line">        proxy.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果与 jdk 动态代理相同</p>
<h4 id="收获💡-18"><a href="#收获💡-18" class="headerlink" title="收获💡"></a>收获💡</h4><ul>
<li>cglib 不要求目标实现接口，它生成的代理类是目标的子类，因此代理与目标之间是子父关系</li>
<li>限制⛔：根据上述分析 final 类无法被 cglib 增强</li>
</ul>
<h3 id="12-jdk-动态代理进阶"><a href="#12-jdk-动态代理进阶" class="headerlink" title="12) jdk 动态代理进阶"></a>12) jdk 动态代理进阶</h3><h4 id="演示1-模拟-jdk-动态代理"><a href="#演示1-模拟-jdk-动态代理" class="headerlink" title="演示1 - 模拟 jdk 动态代理"></a>演示1 - 模拟 jdk 动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A12</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target bar&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] param)</span> &#123;</span><br><span class="line">        <span class="comment">// ⬇️1. 创建代理，这时传入 InvocationHandler</span></span><br><span class="line">        <span class="type">Foo</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;  </span><br><span class="line">            <span class="comment">// ⬇️5. 进入 InvocationHandler</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">                <span class="comment">// ⬇️6. 功能增强</span></span><br><span class="line">                System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">                <span class="comment">// ⬇️7. 反射调用目标方法</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">new</span> <span class="title class_">Target</span>(), args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// ⬇️2. 调用代理方法</span></span><br><span class="line">        proxy.foo();</span><br><span class="line">        proxy.bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟代理实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⬇️这就是 jdk 代理类的源码, 秘密都在里面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">A12</span>.Foo &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">super</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⬇️3. 进入代理方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ⬇️4. 回调 InvocationHandler</span></span><br><span class="line">            h.invoke(<span class="built_in">this</span>, foo, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> h.invoke(<span class="built_in">this</span>, bar, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Method foo;</span><br><span class="line">    <span class="keyword">static</span> Method bar;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            foo = A12.Foo.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">            bar = A12.Foo.class.getMethod(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="收获💡-19"><a href="#收获💡-19" class="headerlink" title="收获💡"></a>收获💡</h4><p>代理一点都不难，无非就是利用了多态、反射的知识</p>
<ol>
<li>方法重写可以增强逻辑，只不过这【增强逻辑】千变万化，不能写死在代理内部</li>
<li>通过接口回调将【增强逻辑】置于代理类之外</li>
<li>配合接口方法反射（是多态调用），就可以再联动调用目标方法</li>
<li>会用 arthas 的 jad 工具反编译代理类</li>
<li>限制⛔：代理增强是借助多态来实现，因此成员变量、静态方法、final 方法均不能通过代理实现</li>
</ol>
<h4 id="演示2-方法反射优化"><a href="#演示2-方法反射优化" class="headerlink" title="演示2 - 方法反射优化"></a>演示2 - 方法反射优化</h4><h5 id="代码参考-15"><a href="#代码参考-15" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a12.TestMethodInvoke</strong></p>
<h4 id="收获💡-20"><a href="#收获💡-20" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>前 16 次反射性能较低</li>
<li>第 17 次调用会生成代理类，优化为非反射调用</li>
<li>会用 arthas 的 jad 工具反编译第 17 次调用生成的代理类</li>
</ol>
<blockquote>
<p><em><strong>注意</strong></em></p>
<p>运行时请添加 –add-opens java.base&#x2F;java.lang.reflect&#x3D;ALL-UNNAMED –add-opens java.base&#x2F;jdk.internal.reflect&#x3D;ALL-UNNAMED</p>
</blockquote>
<h3 id="13-cglib-代理进阶"><a href="#13-cglib-代理进阶" class="headerlink" title="13) cglib 代理进阶"></a>13) cglib 代理进阶</h3><h4 id="演示-模拟-cglib-代理"><a href="#演示-模拟-cglib-代理" class="headerlink" title="演示 - 模拟 cglib 代理"></a>演示 - 模拟 cglib 代理</h4><h5 id="代码参考-16"><a href="#代码参考-16" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a13</strong> 包</p>
<h4 id="收获💡-21"><a href="#收获💡-21" class="headerlink" title="收获💡"></a>收获💡</h4><p>和 jdk 动态代理原理查不多</p>
<ol>
<li>回调的接口换了一下，InvocationHandler 改成了 MethodInterceptor</li>
<li>调用目标时有所改进，见下面代码片段<ol>
<li>method.invoke 是反射调用，必须调用到足够次数才会进行优化</li>
<li>methodProxy.invoke 是不反射调用，它会正常（间接）调用目标对象的方法（Spring 采用）</li>
<li>methodProxy.invokeSuper 也是不反射调用，它会正常（间接）调用代理对象的方法，可以省略目标对象</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A14Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>();</span><br><span class="line">    </span><br><span class="line">        proxy.setCallbacks(<span class="keyword">new</span> <span class="title class_">Callback</span>[]&#123;(MethodInterceptor) (p, m, a, mp) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;proxy before...&quot;</span> + mp.getSignature());</span><br><span class="line">            <span class="comment">// ⬇️调用目标方法(三种)</span></span><br><span class="line"><span class="comment">//            Object result = m.invoke(target, a);  // ⬅️反射调用</span></span><br><span class="line"><span class="comment">//            Object result = mp.invoke(target, a); // ⬅️非反射调用, 结合目标用</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> mp.invokeSuper(p, a);   <span class="comment">// ⬅️非反射调用, 结合代理用</span></span><br><span class="line">            System.out.println(<span class="string">&quot;proxy after...&quot;</span> + mp.getSignature());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// ⬇️调用代理方法</span></span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em><strong>注意</strong></em></p>
<ul>
<li>调用 Object 的方法, 后两种在 jdk &gt;&#x3D; 9 时都有问题, 需要 –add-opens java.base&#x2F;java.lang&#x3D;ALL-UNNAMED</li>
</ul>
</blockquote>
<h3 id="14-cglib-避免反射调用"><a href="#14-cglib-避免反射调用" class="headerlink" title="14) cglib 避免反射调用"></a>14) cglib 避免反射调用</h3><h4 id="演示-cglib-如何避免反射"><a href="#演示-cglib-如何避免反射" class="headerlink" title="演示 - cglib 如何避免反射"></a>演示 - cglib 如何避免反射</h4><h5 id="代码参考-17"><a href="#代码参考-17" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a13.ProxyFastClass</strong>，<strong>com.itheima.a13.TargetFastClass</strong></p>
<h4 id="收获💡-22"><a href="#收获💡-22" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>当调用 MethodProxy 的 invoke 或 invokeSuper 方法时, 会动态生成两个类<ul>
<li>ProxyFastClass 配合代理对象一起使用, 避免反射</li>
<li>TargetFastClass 配合目标对象一起使用, 避免反射 (Spring 用的这种)</li>
</ul>
</li>
<li>TargetFastClass 记录了 Target 中方法与编号的对应关系<ul>
<li>save(long) 编号 2</li>
<li>save(int) 编号 1</li>
<li>save() 编号 0</li>
<li>首先根据方法名和参数个数、类型, 用 switch 和 if 找到这些方法编号</li>
<li>然后再根据编号去调用目标方法, 又用了一大堆 switch 和 if, 但避免了反射</li>
</ul>
</li>
<li>ProxyFastClass 记录了 Proxy 中方法与编号的对应关系，不过 Proxy 额外提供了下面几个方法<ul>
<li>saveSuper(long) 编号 2，不增强，仅是调用 super.save(long)</li>
<li>saveSuper(int) 编号 1，不增强, 仅是调用 super.save(int)</li>
<li>saveSuper() 编号 0，不增强, 仅是调用 super.save()</li>
<li>查找方式与 TargetFastClass 类似</li>
</ul>
</li>
<li>为什么有这么麻烦的一套东西呢？<ul>
<li>避免反射, 提高性能, 代价是一个代理类配两个 FastClass 类, 代理类中还得增加仅调用 super 的一堆方法</li>
<li>用编号处理方法对应关系比较省内存, 另外, 最初获得方法顺序是不确定的, 这个过程没法固定死</li>
</ul>
</li>
</ol>
<h3 id="15-jdk-和-cglib-在-Spring-中的统一"><a href="#15-jdk-和-cglib-在-Spring-中的统一" class="headerlink" title="15) jdk 和 cglib 在 Spring 中的统一"></a>15) jdk 和 cglib 在 Spring 中的统一</h3><p>Spring 中对切点、通知、切面的抽象如下</p>
<ul>
<li>切点：接口 Pointcut，典型实现 AspectJExpressionPointcut</li>
<li>通知：典型接口为 MethodInterceptor 代表环绕通知</li>
<li>切面：Advisor，包含一个 Advice 通知，PointcutAdvisor 包含一个 Advice 通知和一个 Pointcut</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  classDiagram

class Advice
class MethodInterceptor
class Advisor
class PointcutAdvisor

Pointcut &lt;|-- AspectJExpressionPointcut
Advice &lt;|-- MethodInterceptor
Advisor &lt;|-- PointcutAdvisor
PointcutAdvisor o-- &quot;一&quot; Pointcut
PointcutAdvisor o-- &quot;一&quot; Advice

&lt;&lt;interface&gt;&gt; Advice
&lt;&lt;interface&gt;&gt; MethodInterceptor
&lt;&lt;interface&gt;&gt; Pointcut
&lt;&lt;interface&gt;&gt; Advisor
&lt;&lt;interface&gt;&gt; PointcutAdvisor
  </pre></div>

<p>代理相关类图</p>
<ul>
<li>AopProxyFactory 根据 proxyTargetClass 等设置选择 AopProxy 实现</li>
<li>AopProxy 通过 getProxy 创建代理对象</li>
<li>图中 Proxy 都实现了 Advised 接口，能够获得关联的切面集合与目标（其实是从 ProxyFactory 取得）</li>
<li>调用代理方法时，会借助 ProxyFactory 将通知统一转为环绕通知：MethodInterceptor</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  classDiagram

Advised &lt;|-- ProxyFactory
ProxyFactory o-- Target
ProxyFactory o-- &quot;多&quot; Advisor

ProxyFactory --&gt; AopProxyFactory : 使用
AopProxyFactory --&gt; AopProxy
Advised &lt;|-- 基于CGLIB的Proxy
基于CGLIB的Proxy &lt;-- ObjenesisCglibAopProxy : 创建
AopProxy &lt;|-- ObjenesisCglibAopProxy
AopProxy &lt;|-- JdkDynamicAopProxy
基于JDK的Proxy &lt;-- JdkDynamicAopProxy : 创建
Advised &lt;|-- 基于JDK的Proxy

class AopProxy {
+getProxy() Object
}

class ProxyFactory {
proxyTargetClass : boolean
}

class ObjenesisCglibAopProxy {
advised : ProxyFactory
}

class JdkDynamicAopProxy {
advised : ProxyFactory
}

&lt;&lt;interface&gt;&gt; Advised
&lt;&lt;interface&gt;&gt; AopProxyFactory
&lt;&lt;interface&gt;&gt; AopProxy
  </pre></div>

<h4 id="演示-底层切点、通知、切面"><a href="#演示-底层切点、通知、切面" class="headerlink" title="演示 - 底层切点、通知、切面"></a>演示 - 底层切点、通知、切面</h4><h5 id="代码参考-18"><a href="#代码参考-18" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a15.A15</strong></p>
<h4 id="收获💡-23"><a href="#收获💡-23" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>底层的切点实现</li>
<li>底层的通知实现</li>
<li>底层的切面实现</li>
<li>ProxyFactory 用来创建代理<ul>
<li>如果指定了接口，且 proxyTargetClass &#x3D; false，使用 JdkDynamicAopProxy</li>
<li>如果没有指定接口，或者 proxyTargetClass &#x3D; true，使用 ObjenesisCglibAopProxy<ul>
<li>例外：如果目标是接口类型或已经是 Jdk 代理，使用 JdkDynamicAopProxy</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><em><strong>注意</strong></em></p>
<ul>
<li>要区分本章节提到的 MethodInterceptor，它与之前 cglib 中用的的 MethodInterceptor 是不同的接口</li>
</ul>
</blockquote>
<h3 id="16-切点匹配"><a href="#16-切点匹配" class="headerlink" title="16) 切点匹配"></a>16) 切点匹配</h3><h4 id="演示-切点匹配"><a href="#演示-切点匹配" class="headerlink" title="演示 - 切点匹配"></a>演示 - 切点匹配</h4><h5 id="代码参考-19"><a href="#代码参考-19" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a16.A16</strong></p>
<h4 id="收获💡-24"><a href="#收获💡-24" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>常见 aspectj 切点用法</li>
<li>aspectj 切点的局限性，实际的 @Transactional 切点实现</li>
</ol>
<h3 id="17-从-Aspect-到-Advisor"><a href="#17-从-Aspect-到-Advisor" class="headerlink" title="17) 从 @Aspect 到 Advisor"></a>17) 从 @Aspect 到 Advisor</h3><h4 id="演示1-代理创建器"><a href="#演示1-代理创建器" class="headerlink" title="演示1 - 代理创建器"></a>演示1 - 代理创建器</h4><h5 id="代码参考-20"><a href="#代码参考-20" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>org.springframework.aop.framework.autoproxy</strong> 包</p>
<h4 id="收获💡-25"><a href="#收获💡-25" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>AnnotationAwareAspectJAutoProxyCreator 的作用<ul>
<li>将高级 @Aspect 切面统一为低级 Advisor 切面</li>
<li>在合适的时机创建代理</li>
</ul>
</li>
<li>findEligibleAdvisors 找到有【资格】的 Advisors<ul>
<li>有【资格】的 Advisor 一部分是低级的, 可以由自己编写, 如本例 A17 中的 advisor3</li>
<li>有【资格】的 Advisor 另一部分是高级的, 由解析 @Aspect 后获得</li>
</ul>
</li>
<li>wrapIfNecessary<ul>
<li>它内部调用 findEligibleAdvisors, 只要返回集合不空, 则表示需要创建代理</li>
<li>它的调用时机通常在原始对象初始化后执行, 但碰到循环依赖会提前至依赖注入之前执行</li>
</ul>
</li>
</ol>
<h4 id="演示2-代理创建时机"><a href="#演示2-代理创建时机" class="headerlink" title="演示2 - 代理创建时机"></a>演示2 - 代理创建时机</h4><h5 id="代码参考-21"><a href="#代码参考-21" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>org.springframework.aop.framework.autoproxy.A17_1</strong></p>
<h4 id="收获💡-26"><a href="#收获💡-26" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>代理的创建时机<ul>
<li>初始化之后 (无循环依赖时)</li>
<li>实例创建后, 依赖注入前 (有循环依赖时), 并暂存于二级缓存</li>
</ul>
</li>
<li>依赖注入与初始化不应该被增强, 仍应被施加于原始对象</li>
</ol>
<h4 id="演示3-Before-对应的低级通知"><a href="#演示3-Before-对应的低级通知" class="headerlink" title="演示3 - @Before 对应的低级通知"></a>演示3 - @Before 对应的低级通知</h4><h5 id="代码参考-22"><a href="#代码参考-22" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>org.springframework.aop.framework.autoproxy.A17_2</strong></p>
<h4 id="收获💡-27"><a href="#收获💡-27" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>@Before 前置通知会被转换为原始的 AspectJMethodBeforeAdvice 形式, 该对象包含了如下信息<ol>
<li>通知代码从哪儿来</li>
<li>切点是什么(这里为啥要切点, 后面解释)</li>
<li>通知对象如何创建, 本例共用同一个 Aspect 对象</li>
</ol>
</li>
<li>类似的还有<ol>
<li>AspectJAroundAdvice (环绕通知)</li>
<li>AspectJAfterReturningAdvice</li>
<li>AspectJAfterThrowingAdvice (环绕通知)</li>
<li>AspectJAfterAdvice (环绕通知)</li>
</ol>
</li>
</ol>
<h3 id="18-静态通知调用"><a href="#18-静态通知调用" class="headerlink" title="18) 静态通知调用"></a>18) 静态通知调用</h3><p>代理对象调用流程如下（以 JDK 动态代理实现为例）</p>
<ul>
<li>从 ProxyFactory 获得 Target 和环绕通知链，根据他俩创建 MethodInvocation，简称 mi</li>
<li>首次执行 mi.proceed() 发现有下一个环绕通知，调用它的 invoke(mi)</li>
<li>进入环绕通知1，执行前增强，再次调用 mi.proceed() 发现有下一个环绕通知，调用它的 invoke(mi)</li>
<li>进入环绕通知2，执行前增强，调用 mi.proceed() 发现没有环绕通知，调用 mi.invokeJoinPoint() 执行目标方法</li>
<li>目标方法执行结束，将结果返回给环绕通知2，执行环绕通知2 的后增强</li>
<li>环绕通知2继续将结果返回给环绕通知1，执行环绕通知1 的后增强</li>
<li>环绕通知1返回最终的结果</li>
</ul>
<p>图中不同颜色对应一次环绕通知或目标的调用起始至终结</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  sequenceDiagram
participant Proxy
participant ih as InvocationHandler
participant mi as MethodInvocation
participant Factory as ProxyFactory
participant mi1 as MethodInterceptor1
participant mi2 as MethodInterceptor2
participant Target

Proxy -&gt;&gt; +ih : invoke()
ih -&gt;&gt; +Factory : 获得 Target
Factory --&gt;&gt; -ih : 
ih -&gt;&gt; +Factory : 获得 MethodInterceptor 链
Factory --&gt;&gt; -ih : 
ih -&gt;&gt; +mi : 创建 mi
mi --&gt;&gt; -ih : 
rect rgb(200, 223, 255)
ih -&gt;&gt; +mi : mi.proceed()
mi -&gt;&gt; +mi1 : invoke(mi)
mi1 -&gt;&gt; mi1 : 前增强
rect rgb(200, 190, 255)
mi1 -&gt;&gt; mi : mi.proceed()
mi -&gt;&gt; +mi2 : invoke(mi)
mi2 -&gt;&gt; mi2 : 前增强
rect rgb(150, 190, 155)
mi2 -&gt;&gt; mi : mi.proceed()
mi -&gt;&gt; +Target : mi.invokeJoinPoint()
Target -&gt;&gt; Target : 
Target --&gt;&gt; -mi2 : 结果
end
mi2 -&gt;&gt; mi2 : 后增强
mi2 --&gt;&gt; -mi1 : 结果
end
mi1 -&gt;&gt; mi1 : 后增强
mi1 --&gt;&gt; -mi : 结果
mi --&gt;&gt; -ih : 
end
ih --&gt;&gt; -Proxy : 
  </pre></div>

<h4 id="演示1-通知调用过程"><a href="#演示1-通知调用过程" class="headerlink" title="演示1 - 通知调用过程"></a>演示1 - 通知调用过程</h4><h5 id="代码参考-23"><a href="#代码参考-23" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>org.springframework.aop.framework.A18</strong></p>
<h4 id="收获💡-28"><a href="#收获💡-28" class="headerlink" title="收获💡"></a>收获💡</h4><p>代理方法执行时会做如下工作</p>
<ol>
<li>通过 proxyFactory 的 getInterceptorsAndDynamicInterceptionAdvice() 将其他通知统一转换为 MethodInterceptor 环绕通知<ul>
<li>MethodBeforeAdviceAdapter 将 @Before AspectJMethodBeforeAdvice 适配为 MethodBeforeAdviceInterceptor</li>
<li>AfterReturningAdviceAdapter 将 @AfterReturning AspectJAfterReturningAdvice 适配为 AfterReturningAdviceInterceptor</li>
<li>这体现的是适配器设计模式</li>
</ul>
</li>
<li>所谓静态通知，体现在上面方法的 Interceptors 部分，这些通知调用时无需再次检查切点，直接调用即可</li>
<li>结合目标与环绕通知链，创建 MethodInvocation 对象，通过它完成整个调用</li>
</ol>
<h4 id="演示2-模拟-MethodInvocation"><a href="#演示2-模拟-MethodInvocation" class="headerlink" title="演示2 - 模拟 MethodInvocation"></a>演示2 - 模拟 MethodInvocation</h4><h5 id="代码参考-24"><a href="#代码参考-24" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>org.springframework.aop.framework.A18_1</strong></p>
<h4 id="收获💡-29"><a href="#收获💡-29" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>proceed() 方法调用链中下一个环绕通知</li>
<li>每个环绕通知内部继续调用 proceed()</li>
<li>调用到没有更多通知了, 就调用目标方法</li>
</ol>
<p>MethodInvocation 的编程技巧在实现拦截器、过滤器时能用上</p>
<h3 id="19-动态通知调用"><a href="#19-动态通知调用" class="headerlink" title="19) 动态通知调用"></a>19) 动态通知调用</h3><h4 id="演示-带参数绑定的通知方法调用"><a href="#演示-带参数绑定的通知方法调用" class="headerlink" title="演示 - 带参数绑定的通知方法调用"></a>演示 - 带参数绑定的通知方法调用</h4><h5 id="代码参考-25"><a href="#代码参考-25" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>org.springframework.aop.framework.autoproxy.A19</strong></p>
<h4 id="收获💡-30"><a href="#收获💡-30" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>通过 proxyFactory 的 getInterceptorsAndDynamicInterceptionAdvice() 将其他通知统一转换为 MethodInterceptor 环绕通知</li>
<li>所谓动态通知，体现在上面方法的 DynamicInterceptionAdvice 部分，这些通知调用时因为要为通知方法绑定参数，还需再次利用切点表达式</li>
<li>动态通知调用复杂程度高，性能较低</li>
</ol>
<h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="20-RequestMappingHandlerMapping-与-RequestMappingHandlerAdapter"><a href="#20-RequestMappingHandlerMapping-与-RequestMappingHandlerAdapter" class="headerlink" title="20) RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter"></a>20) RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter</h3><p>RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter 俩是一对，分别用来</p>
<ul>
<li>处理 @RequestMapping 映射</li>
<li>调用控制器方法、并处理方法参数与方法返回值</li>
</ul>
<h4 id="演示1-DispatcherServlet-初始化"><a href="#演示1-DispatcherServlet-初始化" class="headerlink" title="演示1 - DispatcherServlet 初始化"></a>演示1 - DispatcherServlet 初始化</h4><h5 id="代码参考-26"><a href="#代码参考-26" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a20</strong> 包</p>
<h4 id="收获💡-31"><a href="#收获💡-31" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>DispatcherServlet 是在第一次被访问时执行初始化, 也可以通过配置修改为 Tomcat 启动后就初始化</li>
<li>在初始化时会从 Spring 容器中找一些 Web 需要的组件, 如 HandlerMapping、HandlerAdapter 等，并逐一调用它们的初始化</li>
<li>RequestMappingHandlerMapping 初始化时，会收集所有 @RequestMapping 映射信息，封装为 Map，其中<ul>
<li>key 是 RequestMappingInfo 类型，包括请求路径、请求方法等信息</li>
<li>value 是 HandlerMethod 类型，包括控制器方法对象、控制器对象</li>
<li>有了这个 Map，就可以在请求到达时，快速完成映射，找到 HandlerMethod 并与匹配的拦截器一起返回给 DispatcherServlet</li>
</ul>
</li>
<li>RequestMappingHandlerAdapter 初始化时，会准备 HandlerMethod 调用时需要的各个组件，如：<ul>
<li>HandlerMethodArgumentResolver 解析控制器方法参数</li>
<li>HandlerMethodReturnValueHandler 处理控制器方法返回值</li>
</ul>
</li>
</ol>
<h4 id="演示2-自定义参数与返回值处理器"><a href="#演示2-自定义参数与返回值处理器" class="headerlink" title="演示2 - 自定义参数与返回值处理器"></a>演示2 - 自定义参数与返回值处理器</h4><h5 id="代码参考-27"><a href="#代码参考-27" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a20.TokenArgumentResolver</strong> ，<strong>com.itheima.a20.YmlReturnValueHandler</strong></p>
<h4 id="收获💡-32"><a href="#收获💡-32" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>体会参数解析器的作用</li>
<li>体会返回值处理器的作用</li>
</ol>
<h3 id="21-参数解析器"><a href="#21-参数解析器" class="headerlink" title="21) 参数解析器"></a>21) 参数解析器</h3><h4 id="演示-常见参数解析器"><a href="#演示-常见参数解析器" class="headerlink" title="演示 - 常见参数解析器"></a>演示 - 常见参数解析器</h4><h5 id="代码参考-28"><a href="#代码参考-28" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a21</strong> 包</p>
<h4 id="收获💡-33"><a href="#收获💡-33" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>初步了解 RequestMappingHandlerAdapter 的调用过程<ol>
<li>控制器方法被封装为 HandlerMethod</li>
<li>准备对象绑定与类型转换</li>
<li>准备 ModelAndViewContainer 用来存储中间 Model 结果</li>
<li>解析每个参数值</li>
</ol>
</li>
<li>解析参数依赖的就是各种参数解析器，它们都有两个重要方法<ul>
<li>supportsParameter 判断是否支持方法参数</li>
<li>resolveArgument 解析方法参数</li>
</ul>
</li>
<li>常见参数的解析<ul>
<li>@RequestParam</li>
<li>省略 @RequestParam</li>
<li>@RequestParam(defaultValue)</li>
<li>MultipartFile</li>
<li>@PathVariable</li>
<li>@RequestHeader</li>
<li>@CookieValue</li>
<li>@Value</li>
<li>HttpServletRequest 等</li>
<li>@ModelAttribute</li>
<li>省略 @ModelAttribute</li>
<li>@RequestBody</li>
</ul>
</li>
<li>组合模式在 Spring 中的体现</li>
<li>@RequestParam, @CookieValue 等注解中的参数名、默认值, 都可以写成活的, 即从 ${ } #{ }中获取</li>
</ol>
<h3 id="22-参数名解析"><a href="#22-参数名解析" class="headerlink" title="22) 参数名解析"></a>22) 参数名解析</h3><h4 id="演示-两种方法获取参数名"><a href="#演示-两种方法获取参数名" class="headerlink" title="演示 - 两种方法获取参数名"></a>演示 - 两种方法获取参数名</h4><h5 id="代码参考-29"><a href="#代码参考-29" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a22.A22</strong></p>
<h4 id="收获💡-34"><a href="#收获💡-34" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>如果编译时添加了 -parameters 可以生成参数表, 反射时就可以拿到参数名</li>
<li>如果编译时添加了 -g 可以生成调试信息, 但分为两种情况<ul>
<li>普通类, 会包含局部变量表, 用 asm 可以拿到参数名</li>
<li>接口, 不会包含局部变量表, 无法获得参数名<ul>
<li>这也是 MyBatis 在实现 Mapper 接口时为何要提供 @Param 注解来辅助获得参数名</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="23-对象绑定与类型转换"><a href="#23-对象绑定与类型转换" class="headerlink" title="23) 对象绑定与类型转换"></a>23) 对象绑定与类型转换</h3><h4 id="底层第一套转换接口与实现"><a href="#底层第一套转换接口与实现" class="headerlink" title="底层第一套转换接口与实现"></a>底层第一套转换接口与实现</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  classDiagram

Formatter --|&gt; Printer
Formatter --|&gt; Parser

class Converters {
Set~GenericConverter~
}
class Converter

class ConversionService
class FormattingConversionService

ConversionService &lt;|-- FormattingConversionService
FormattingConversionService o-- Converters

Printer --&gt; Adapter1
Adapter1 --&gt; Converters
Parser --&gt; Adapter2
Adapter2 --&gt; Converters
Converter --&gt; Adapter3
Adapter3 --&gt; Converters

&lt;&lt;interface&gt;&gt; Formatter
&lt;&lt;interface&gt;&gt; Printer
&lt;&lt;interface&gt;&gt; Parser
&lt;&lt;interface&gt;&gt; Converter
&lt;&lt;interface&gt;&gt; ConversionService
  </pre></div>

<ul>
<li>Printer 把其它类型转为 String</li>
<li>Parser 把 String 转为其它类型</li>
<li>Formatter 综合 Printer 与 Parser 功能</li>
<li>Converter 把类型 S 转为类型 T</li>
<li>Printer、Parser、Converter 经过适配转换成 GenericConverter 放入 Converters 集合</li>
<li>FormattingConversionService 利用其它们实现转换</li>
</ul>
<h4 id="底层第二套转换接口"><a href="#底层第二套转换接口" class="headerlink" title="底层第二套转换接口"></a>底层第二套转换接口</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  classDiagram

PropertyEditorRegistry o-- &quot;多&quot; PropertyEditor

&lt;&lt;interface&gt;&gt; PropertyEditorRegistry
&lt;&lt;interface&gt;&gt; PropertyEditor
  </pre></div>

<ul>
<li>PropertyEditor 把 String 与其它类型相互转换</li>
<li>PropertyEditorRegistry 可以注册多个 PropertyEditor 对象</li>
<li>与第一套接口直接可以通过 FormatterPropertyEditorAdapter 来进行适配</li>
</ul>
<h4 id="高层接口与实现"><a href="#高层接口与实现" class="headerlink" title="高层接口与实现"></a>高层接口与实现</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  classDiagram
TypeConverter &lt;|-- SimpleTypeConverter
TypeConverter &lt;|-- BeanWrapperImpl
TypeConverter &lt;|-- DirectFieldAccessor
TypeConverter &lt;|-- ServletRequestDataBinder

SimpleTypeConverter --&gt; TypeConverterDelegate
BeanWrapperImpl --&gt; TypeConverterDelegate
DirectFieldAccessor --&gt; TypeConverterDelegate
ServletRequestDataBinder --&gt; TypeConverterDelegate

TypeConverterDelegate --&gt; ConversionService
TypeConverterDelegate --&gt; PropertyEditorRegistry

&lt;&lt;interface&gt;&gt; TypeConverter
&lt;&lt;interface&gt;&gt; ConversionService
&lt;&lt;interface&gt;&gt; PropertyEditorRegistry
  </pre></div>

<ul>
<li>它们都实现了 TypeConverter 这个高层转换接口，在转换时，会用到 TypeConverter Delegate 委派ConversionService 与 PropertyEditorRegistry 真正执行转换（Facade 门面模式）<ul>
<li>首先看是否有自定义转换器, @InitBinder 添加的即属于这种 (用了适配器模式把 Formatter 转为需要的 PropertyEditor)</li>
<li>再看有没有 ConversionService 转换</li>
<li>再利用默认的 PropertyEditor 转换</li>
<li>最后有一些特殊处理</li>
</ul>
</li>
<li>SimpleTypeConverter 仅做类型转换</li>
<li>BeanWrapperImpl 为 bean 的属性赋值，当需要时做类型转换，走 Property</li>
<li>DirectFieldAccessor 为 bean 的属性赋值，当需要时做类型转换，走 Field</li>
<li>ServletRequestDataBinder 为 bean 的属性执行绑定，当需要时做类型转换，根据 directFieldAccess 选择走 Property 还是 Field，具备校验与获取校验结果功能</li>
</ul>
<h4 id="演示1-类型转换与数据绑定"><a href="#演示1-类型转换与数据绑定" class="headerlink" title="演示1 - 类型转换与数据绑定"></a>演示1 - 类型转换与数据绑定</h4><h5 id="代码参考-30"><a href="#代码参考-30" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a23</strong> 包</p>
<h4 id="收获💡-35"><a href="#收获💡-35" class="headerlink" title="收获💡"></a>收获💡</h4><p>基本的类型转换与数据绑定用法</p>
<ul>
<li>SimpleTypeConverter</li>
<li>BeanWrapperImpl</li>
<li>DirectFieldAccessor</li>
<li>ServletRequestDataBinder</li>
</ul>
<h4 id="演示2-数据绑定工厂"><a href="#演示2-数据绑定工厂" class="headerlink" title="演示2 - 数据绑定工厂"></a>演示2 - 数据绑定工厂</h4><h5 id="代码参考-31"><a href="#代码参考-31" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a23.TestServletDataBinderFactory</strong></p>
<h4 id="收获💡-36"><a href="#收获💡-36" class="headerlink" title="收获💡"></a>收获💡</h4><p>ServletRequestDataBinderFactory 的用法和扩展点</p>
<ol>
<li>可以解析控制器的 @InitBinder 标注方法作为扩展点，添加自定义转换器<ul>
<li>控制器私有范围</li>
</ul>
</li>
<li>可以通过 ConfigurableWebBindingInitializer 配置 ConversionService 作为扩展点，添加自定义转换器<ul>
<li>公共范围</li>
</ul>
</li>
<li>同时加了 @InitBinder 和 ConversionService 的转换优先级<ol>
<li>优先采用 @InitBinder 的转换器</li>
<li>其次使用 ConversionService 的转换器</li>
<li>使用默认转换器</li>
<li>特殊处理（例如有参构造）</li>
</ol>
</li>
</ol>
<h4 id="演示3-获取泛型参数"><a href="#演示3-获取泛型参数" class="headerlink" title="演示3 - 获取泛型参数"></a>演示3 - 获取泛型参数</h4><h5 id="代码参考-32"><a href="#代码参考-32" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a23.sub</strong> 包</p>
<h4 id="收获💡-37"><a href="#收获💡-37" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>java api 获取泛型参数</li>
<li>spring api 获取泛型参数</li>
</ol>
<h3 id="24-ControllerAdvice-之-InitBinder"><a href="#24-ControllerAdvice-之-InitBinder" class="headerlink" title="24) @ControllerAdvice 之 @InitBinder"></a>24) @ControllerAdvice 之 @InitBinder</h3><h4 id="演示-准备-InitBinder"><a href="#演示-准备-InitBinder" class="headerlink" title="演示 - 准备 @InitBinder"></a>演示 - 准备 @InitBinder</h4><p><strong>准备 @InitBinder</strong> 在整个 HandlerAdapter 调用过程中所处的位置</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  sequenceDiagram
participant adapter as HandlerAdapter
participant bf as WebDataBinderFactory
participant mf as ModelFactory
participant ihm as ServletInvocableHandlerMethod
participant ar as ArgumentResolvers 
participant rh as ReturnValueHandlers
participant container as ModelAndViewContainer
rect rgb(200, 150, 255)
adapter -&gt;&gt; +bf: 准备 @InitBinder
bf --&gt;&gt; -adapter: 
end
adapter -&gt;&gt; +mf: 准备 @ModelAttribute
mf -&gt;&gt; +container: 添加Model数据
container --&gt;&gt; -mf: 
mf --&gt;&gt; -adapter: 

adapter -&gt;&gt; +ihm: invokeAndHandle
ihm -&gt;&gt; +ar: 获取 args
ar -&gt;&gt; ar: 有的解析器涉及 RequestBodyAdvice
ar -&gt;&gt; container: 有的解析器涉及数据绑定生成Model数据
ar --&gt;&gt; -ihm: args
ihm -&gt;&gt; ihm: method.invoke(bean,args) 得到 returnValue
ihm -&gt;&gt; +rh: 处理 returnValue
rh -&gt;&gt; rh: 有的处理器涉及 ResponseBodyAdvice
rh -&gt;&gt; +container: 添加Model数据,处理视图名,是否渲染等
container --&gt;&gt; -rh: 
rh --&gt;&gt; -ihm: 
ihm --&gt;&gt; -adapter: 
adapter -&gt;&gt; +container: 获取 ModelAndView
container --&gt;&gt; -adapter: 
  </pre></div>

<ul>
<li>RequestMappingHandlerAdapter 在图中缩写为 HandlerAdapter</li>
<li>HandlerMethodArgumentResolverComposite 在图中缩写为 ArgumentResolvers</li>
<li>HandlerMethodReturnValueHandlerComposite 在图中缩写为 ReturnValueHandlers</li>
</ul>
<h4 id="收获💡-38"><a href="#收获💡-38" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>RequestMappingHandlerAdapter 初始化时会解析 @ControllerAdvice 中的 @InitBinder 方法</li>
<li>RequestMappingHandlerAdapter 会以类为单位，在该类首次使用时，解析此类的 @InitBinder 方法</li>
<li>以上两种 @InitBinder 的解析结果都会缓存来避免重复解析</li>
<li>控制器方法调用时，会综合利用本类的 @InitBinder 方法和 @ControllerAdvice 中的 @InitBinder 方法创建绑定工厂</li>
</ol>
<h3 id="25-控制器方法执行流程"><a href="#25-控制器方法执行流程" class="headerlink" title="25) 控制器方法执行流程"></a>25) 控制器方法执行流程</h3><h4 id="图1"><a href="#图1" class="headerlink" title="图1"></a>图1</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  classDiagram
class ServletInvocableHandlerMethod {
+invokeAndHandle(ServletWebRequest,ModelAndViewContainer)
}
HandlerMethod &lt;|-- ServletInvocableHandlerMethod
HandlerMethod o-- bean
HandlerMethod o-- method
ServletInvocableHandlerMethod o-- WebDataBinderFactory
ServletInvocableHandlerMethod o-- ParameterNameDiscoverer
ServletInvocableHandlerMethod o-- HandlerMethodArgumentResolverComposite
ServletInvocableHandlerMethod o-- HandlerMethodReturnValueHandlerComposite
  </pre></div>

<p>HandlerMethod 需要</p>
<ul>
<li>bean 即是哪个 Controller</li>
<li>method 即是 Controller 中的哪个方法</li>
</ul>
<p>ServletInvocableHandlerMethod 需要</p>
<ul>
<li>WebDataBinderFactory 负责对象绑定、类型转换</li>
<li>ParameterNameDiscoverer 负责参数名解析</li>
<li>HandlerMethodArgumentResolverComposite 负责解析参数</li>
<li>HandlerMethodReturnValueHandlerComposite 负责处理返回值</li>
</ul>
<h4 id="图2"><a href="#图2" class="headerlink" title="图2"></a>图2</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  sequenceDiagram
participant adapter as RequestMappingHandlerAdapter
participant bf as WebDataBinderFactory
participant mf as ModelFactory
participant container as ModelAndViewContainer
adapter -&gt;&gt; +bf: 准备 @InitBinder
bf --&gt;&gt; -adapter: 
adapter -&gt;&gt; +mf: 准备 @ModelAttribute
mf -&gt;&gt; +container: 添加Model数据
container --&gt;&gt; -mf: 
mf --&gt;&gt; -adapter:  
  </pre></div>

<h4 id="图3"><a href="#图3" class="headerlink" title="图3"></a>图3</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  sequenceDiagram
participant adapter as RequestMappingHandlerAdapter
participant ihm as ServletInvocableHandlerMethod
participant ar as ArgumentResolvers
participant rh as ReturnValueHandlers
participant container as ModelAndViewContainer

adapter -&gt;&gt; +ihm: invokeAndHandle
ihm -&gt;&gt; +ar: 获取 args
ar -&gt;&gt; ar: 有的解析器涉及 RequestBodyAdvice
ar -&gt;&gt; container: 有的解析器涉及数据绑定生成模型数据
container --&gt;&gt; ar: 
ar --&gt;&gt; -ihm: args
ihm -&gt;&gt; ihm: method.invoke(bean,args) 得到 returnValue
ihm -&gt;&gt; +rh: 处理 returnValue
rh -&gt;&gt; rh: 有的处理器涉及 ResponseBodyAdvice
rh -&gt;&gt; +container: 添加Model数据,处理视图名,是否渲染等
container --&gt;&gt; -rh: 
rh --&gt;&gt; -ihm: 
ihm --&gt;&gt; -adapter:  
adapter -&gt;&gt; +container: 获取 ModelAndView
container --&gt;&gt; -adapter: 
  </pre></div>

<h3 id="26-ControllerAdvice-之-ModelAttribute"><a href="#26-ControllerAdvice-之-ModelAttribute" class="headerlink" title="26) @ControllerAdvice 之 @ModelAttribute"></a>26) @ControllerAdvice 之 @ModelAttribute</h3><h4 id="演示-准备-ModelAttribute"><a href="#演示-准备-ModelAttribute" class="headerlink" title="演示 - 准备 @ModelAttribute"></a>演示 - 准备 @ModelAttribute</h4><h5 id="代码参考-33"><a href="#代码参考-33" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a26</strong> 包</p>
<p><strong>准备 @ModelAttribute</strong> 在整个 HandlerAdapter 调用过程中所处的位置</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  sequenceDiagram
participant adapter as HandlerAdapter
participant bf as WebDataBinderFactory
participant mf as ModelFactory
participant ihm as ServletInvocableHandlerMethod
participant ar as ArgumentResolvers 
participant rh as ReturnValueHandlers
participant container as ModelAndViewContainer

adapter -&gt;&gt; +bf: 准备 @InitBinder
bf --&gt;&gt; -adapter: 
rect rgb(200, 150, 255)
adapter -&gt;&gt; +mf: 准备 @ModelAttribute
mf -&gt;&gt; +container: 添加Model数据
container --&gt;&gt; -mf: 
mf --&gt;&gt; -adapter: 
end
adapter -&gt;&gt; +ihm: invokeAndHandle
ihm -&gt;&gt; +ar: 获取 args
ar -&gt;&gt; ar: 有的解析器涉及 RequestBodyAdvice
ar -&gt;&gt; container: 有的解析器涉及数据绑定生成Model数据
ar --&gt;&gt; -ihm: args
ihm -&gt;&gt; ihm: method.invoke(bean,args) 得到 returnValue
ihm -&gt;&gt; +rh: 处理 returnValue
rh -&gt;&gt; rh: 有的处理器涉及 ResponseBodyAdvice
rh -&gt;&gt; +container: 添加Model数据,处理视图名,是否渲染等
container --&gt;&gt; -rh: 
rh --&gt;&gt; -ihm: 
ihm --&gt;&gt; -adapter: 
adapter -&gt;&gt; +container: 获取 ModelAndView
container --&gt;&gt; -adapter: 
  </pre></div>

<h4 id="收获💡-39"><a href="#收获💡-39" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>RequestMappingHandlerAdapter 初始化时会解析 @ControllerAdvice 中的 @ModelAttribute 方法</li>
<li>RequestMappingHandlerAdapter 会以类为单位，在该类首次使用时，解析此类的 @ModelAttribute 方法</li>
<li>以上两种 @ModelAttribute 的解析结果都会缓存来避免重复解析</li>
<li>控制器方法调用时，会综合利用本类的 @ModelAttribute 方法和 @ControllerAdvice 中的 @ModelAttribute 方法创建模型工厂</li>
</ol>
<h3 id="27-返回值处理器"><a href="#27-返回值处理器" class="headerlink" title="27) 返回值处理器"></a>27) 返回值处理器</h3><h4 id="演示-常见返回值处理器"><a href="#演示-常见返回值处理器" class="headerlink" title="演示 - 常见返回值处理器"></a>演示 - 常见返回值处理器</h4><h5 id="代码参考-34"><a href="#代码参考-34" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a27</strong> 包</p>
<h4 id="收获💡-40"><a href="#收获💡-40" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>常见的返回值处理器<ul>
<li>ModelAndView，分别获取其模型和视图名，放入 ModelAndViewContainer</li>
<li>返回值类型为 String 时，把它当做视图名，放入 ModelAndViewContainer</li>
<li>返回值添加了 @ModelAttribute 注解时，将返回值作为模型，放入 ModelAndViewContainer<ul>
<li>此时需找到默认视图名</li>
</ul>
</li>
<li>返回值省略 @ModelAttribute 注解且返回非简单类型时，将返回值作为模型，放入 ModelAndViewContainer<ul>
<li>此时需找到默认视图名</li>
</ul>
</li>
<li>返回值类型为 ResponseEntity 时<ul>
<li>此时走 MessageConverter，并设置 ModelAndViewContainer.requestHandled 为 true</li>
</ul>
</li>
<li>返回值类型为 HttpHeaders 时<ul>
<li>会设置 ModelAndViewContainer.requestHandled 为 true</li>
</ul>
</li>
<li>返回值添加了 @ResponseBody 注解时<ul>
<li>此时走 MessageConverter，并设置 ModelAndViewContainer.requestHandled 为 true</li>
</ul>
</li>
</ul>
</li>
<li>组合模式在 Spring 中的体现 + 1</li>
</ol>
<h3 id="28-MessageConverter"><a href="#28-MessageConverter" class="headerlink" title="28) MessageConverter"></a>28) MessageConverter</h3><h4 id="演示-MessageConverter-的作用"><a href="#演示-MessageConverter-的作用" class="headerlink" title="演示 - MessageConverter 的作用"></a>演示 - MessageConverter 的作用</h4><h5 id="代码参考-35"><a href="#代码参考-35" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a28.A28</strong></p>
<h4 id="收获💡-41"><a href="#收获💡-41" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>MessageConverter 的作用<ul>
<li>@ResponseBody 是返回值处理器解析的</li>
<li>但具体转换工作是 MessageConverter 做的</li>
</ul>
</li>
<li>如何选择 MediaType<ul>
<li>首先看 @RequestMapping 上有没有指定</li>
<li>其次看 request 的 Accept 头有没有指定</li>
<li>最后按 MessageConverter 的顺序, 谁能谁先转换</li>
</ul>
</li>
</ol>
<h3 id="29-ControllerAdvice-之-ResponseBodyAdvice"><a href="#29-ControllerAdvice-之-ResponseBodyAdvice" class="headerlink" title="29) @ControllerAdvice 之 ResponseBodyAdvice"></a>29) @ControllerAdvice 之 ResponseBodyAdvice</h3><h4 id="演示-ResponseBodyAdvice-增强"><a href="#演示-ResponseBodyAdvice-增强" class="headerlink" title="演示 - ResponseBodyAdvice 增强"></a>演示 - ResponseBodyAdvice 增强</h4><h5 id="代码参考-36"><a href="#代码参考-36" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a29</strong> 包</p>
<p><strong>ResponseBodyAdvice 增强</strong> 在整个 HandlerAdapter 调用过程中所处的位置</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  sequenceDiagram
participant adapter as HandlerAdapter
participant bf as WebDataBinderFactory
participant mf as ModelFactory
participant ihm as ServletInvocableHandlerMethod
participant ar as ArgumentResolvers
participant rh as ReturnValueHandlers
participant container as ModelAndViewContainer

adapter -&gt;&gt; +bf: 准备 @InitBinder
bf --&gt;&gt; -adapter: 
adapter -&gt;&gt; +mf: 准备 @ModelAttribute
mf -&gt;&gt; +container: 添加Model数据
container --&gt;&gt; -mf: 
mf --&gt;&gt; -adapter: 
adapter -&gt;&gt; +ihm: invokeAndHandle
ihm -&gt;&gt; +ar: 获取 args
ar -&gt;&gt; ar: 有的解析器涉及 RequestBodyAdvice
ar -&gt;&gt; container: 有的解析器涉及数据绑定生成Model数据
ar --&gt;&gt; -ihm: args
ihm -&gt;&gt; ihm: method.invoke(bean,args) 得到 returnValue
ihm -&gt;&gt; +rh: 处理 returnValue
rect rgb(200, 150, 255)
rh -&gt;&gt; rh: 有的处理器涉及 ResponseBodyAdvice
end
rh -&gt;&gt; +container: 添加Model数据,处理视图名,是否渲染等
container --&gt;&gt; -rh: 
rh --&gt;&gt; -ihm: 
ihm --&gt;&gt; -adapter: 
adapter -&gt;&gt; +container: 获取 ModelAndView
container --&gt;&gt; -adapter: 
  </pre></div>

<h4 id="收获💡-42"><a href="#收获💡-42" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>ResponseBodyAdvice 返回响应体前包装</li>
</ol>
<h3 id="30-异常解析器"><a href="#30-异常解析器" class="headerlink" title="30) 异常解析器"></a>30) 异常解析器</h3><h4 id="演示-ExceptionHandlerExceptionResolver"><a href="#演示-ExceptionHandlerExceptionResolver" class="headerlink" title="演示 - ExceptionHandlerExceptionResolver"></a>演示 - ExceptionHandlerExceptionResolver</h4><h5 id="代码参考-37"><a href="#代码参考-37" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a30.A30</strong></p>
<h4 id="收获💡-43"><a href="#收获💡-43" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>它能够重用参数解析器、返回值处理器，实现组件重用</li>
<li>它能够支持嵌套异常</li>
</ol>
<h3 id="31-ControllerAdvice-之-ExceptionHandler"><a href="#31-ControllerAdvice-之-ExceptionHandler" class="headerlink" title="31) @ControllerAdvice 之 @ExceptionHandler"></a>31) @ControllerAdvice 之 @ExceptionHandler</h3><h4 id="演示-准备-ExceptionHandler"><a href="#演示-准备-ExceptionHandler" class="headerlink" title="演示 - 准备 @ExceptionHandler"></a>演示 - 准备 @ExceptionHandler</h4><h5 id="代码参考-38"><a href="#代码参考-38" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a31</strong> 包</p>
<h4 id="收获💡-44"><a href="#收获💡-44" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>ExceptionHandlerExceptionResolver 初始化时会解析 @ControllerAdvice 中的 @ExceptionHandler 方法</li>
<li>ExceptionHandlerExceptionResolver 会以类为单位，在该类首次处理异常时，解析此类的 @ExceptionHandler 方法</li>
<li>以上两种 @ExceptionHandler 的解析结果都会缓存来避免重复解析</li>
</ol>
<h3 id="32-Tomcat-异常处理"><a href="#32-Tomcat-异常处理" class="headerlink" title="32) Tomcat 异常处理"></a>32) Tomcat 异常处理</h3><ul>
<li><p>我们知道 @ExceptionHandler 只能处理发生在 mvc 流程中的异常，例如控制器内、拦截器内，那么如果是 Filter 出现了异常，如何进行处理呢？</p>
</li>
<li><p>在 Spring Boot 中，是这么实现的：</p>
<ol>
<li>因为内嵌了 Tomcat 容器，因此可以配置 Tomcat 的错误页面，Filter 与 错误页面之间是通过请求转发跳转的，可以在这里做手脚</li>
<li>先通过 ErrorPageRegistrarBeanPostProcessor 这个后处理器配置错误页面地址，默认为 <code>/error</code> 也可以通过 <code>$&#123;server.error.path&#125;</code> 进行配置</li>
<li>当 Filter 发生异常时，不会走 Spring 流程，但会走 Tomcat 的错误处理，于是就希望转发至 <code>/error</code> 这个地址<ul>
<li>当然，如果没有 @ExceptionHandler，那么最终也会走到 Tomcat 的错误处理</li>
</ul>
</li>
<li>Spring Boot 又提供了一个 BasicErrorController，它就是一个标准 @Controller，@RequestMapping 配置为 <code>/error</code>，所以处理异常的职责就又回到了 Spring</li>
<li>异常信息由于会被 Tomcat 放入 request 作用域，因此 BasicErrorController 里也能获取到</li>
<li>具体异常信息会由 DefaultErrorAttributes 封装好</li>
<li>BasicErrorController 通过 Accept 头判断需要生成哪种 MediaType 的响应<ul>
<li>如果要的不是 text&#x2F;html，走 MessageConverter 流程</li>
<li>如果需要 text&#x2F;html，走 mvc 流程，此时又分两种情况<ul>
<li>配置了 ErrorViewResolver，根据状态码去找 View</li>
<li>没配置或没找到，用 BeanNameViewResolver 根据一个固定为 error 的名字找到 View，即所谓的 WhitelabelErrorView</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<p><em><strong>评价</strong></em></p>
<ul>
<li>一个错误处理搞得这么复杂，就问恶心不？</li>
</ul>
</blockquote>
<h4 id="演示1-错误页处理"><a href="#演示1-错误页处理" class="headerlink" title="演示1 - 错误页处理"></a>演示1 - 错误页处理</h4><h5 id="关键代码-1"><a href="#关键代码-1" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">// ⬅️修改了 Tomcat 服务器默认错误地址, 出错时使用请求转发方式跳转</span></span><br><span class="line"><span class="keyword">public</span> ErrorPageRegistrar <span class="title function_">errorPageRegistrar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> webServerFactory -&gt; webServerFactory.addErrorPages(<span class="keyword">new</span> <span class="title class_">ErrorPage</span>(<span class="string">&quot;/error&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span> <span class="comment">// ⬅️TomcatServletWebServerFactory 初始化前用它增强, 注册所有 ErrorPageRegistrar</span></span><br><span class="line"><span class="keyword">public</span> ErrorPageRegistrarBeanPostProcessor <span class="title function_">errorPageRegistrarBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorPageRegistrarBeanPostProcessor</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="收获💡-45"><a href="#收获💡-45" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>Tomcat 的错误页处理手段</li>
</ol>
<h4 id="演示2-BasicErrorController"><a href="#演示2-BasicErrorController" class="headerlink" title="演示2 - BasicErrorController"></a>演示2 - BasicErrorController</h4><h5 id="关键代码-2"><a href="#关键代码-2" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">// ⬅️ErrorProperties 封装环境键值, ErrorAttributes 控制有哪些错误信息</span></span><br><span class="line"><span class="keyword">public</span> BasicErrorController <span class="title function_">basicErrorController</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ErrorProperties</span> <span class="variable">errorProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorProperties</span>();</span><br><span class="line">    errorProperties.setIncludeException(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BasicErrorController</span>(<span class="keyword">new</span> <span class="title class_">DefaultErrorAttributes</span>(), errorProperties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span> <span class="comment">// ⬅️名称为 error 的视图, 作为 BasicErrorController 的 text/html 响应结果</span></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">error</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">View</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">(</span></span><br><span class="line"><span class="params">            Map&lt;String, ?&gt; model, </span></span><br><span class="line"><span class="params">            HttpServletRequest request, </span></span><br><span class="line"><span class="params">            HttpServletResponse response</span></span><br><span class="line"><span class="params">        )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(model);</span><br><span class="line">            response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">            response.getWriter().print(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    &lt;h3&gt;服务器内部错误&lt;/h3&gt;</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span> <span class="comment">// ⬅️收集容器中所有 View 对象, bean 的名字作为视图名</span></span><br><span class="line"><span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanNameViewResolver</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="收获💡-46"><a href="#收获💡-46" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>Spring Boot 中 BasicErrorController 如何工作</li>
</ol>
<h3 id="33-BeanNameUrlHandlerMapping-与-SimpleControllerHandlerAdapter"><a href="#33-BeanNameUrlHandlerMapping-与-SimpleControllerHandlerAdapter" class="headerlink" title="33) BeanNameUrlHandlerMapping 与 SimpleControllerHandlerAdapter"></a>33) BeanNameUrlHandlerMapping 与 SimpleControllerHandlerAdapter</h3><h4 id="演示-本组映射器和适配器"><a href="#演示-本组映射器和适配器" class="headerlink" title="演示 - 本组映射器和适配器"></a>演示 - 本组映射器和适配器</h4><h5 id="关键代码-3"><a href="#关键代码-3" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> BeanNameUrlHandlerMapping <span class="title function_">beanNameUrlHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanNameUrlHandlerMapping</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SimpleControllerHandlerAdapter <span class="title function_">simpleControllerHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleControllerHandlerAdapter</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;/c3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Controller <span class="title function_">controller3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (request, response) -&gt; &#123;</span><br><span class="line">        response.getWriter().print(<span class="string">&quot;this is c3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="收获💡-47"><a href="#收获💡-47" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>BeanNameUrlHandlerMapping，以 &#x2F; 开头的 bean 的名字会被当作映射路径</li>
<li>这些 bean 本身当作 handler，要求实现 Controller 接口</li>
<li>SimpleControllerHandlerAdapter，调用 handler</li>
<li>模拟实现这组映射器和适配器</li>
</ol>
<h3 id="34-RouterFunctionMapping-与-HandlerFunctionAdapter"><a href="#34-RouterFunctionMapping-与-HandlerFunctionAdapter" class="headerlink" title="34) RouterFunctionMapping 与 HandlerFunctionAdapter"></a>34) RouterFunctionMapping 与 HandlerFunctionAdapter</h3><h4 id="演示-本组映射器和适配器-1"><a href="#演示-本组映射器和适配器-1" class="headerlink" title="演示 - 本组映射器和适配器"></a>演示 - 本组映射器和适配器</h4><h5 id="关键代码-4"><a href="#关键代码-4" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RouterFunctionMapping <span class="title function_">routerFunctionMapping</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RouterFunctionMapping</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> HandlerFunctionAdapter <span class="title function_">handlerFunctionAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HandlerFunctionAdapter</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title function_">r1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//           ⬇️映射条件   ⬇️handler</span></span><br><span class="line">    <span class="keyword">return</span> route(GET(<span class="string">&quot;/r1&quot;</span>), request -&gt; ok().body(<span class="string">&quot;this is r1&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="收获💡-48"><a href="#收获💡-48" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>RouterFunctionMapping, 通过 RequestPredicate 条件映射</li>
<li>handler 要实现 HandlerFunction 接口</li>
<li>HandlerFunctionAdapter, 调用 handler</li>
</ol>
<h3 id="35-SimpleUrlHandlerMapping-与-HttpRequestHandlerAdapter"><a href="#35-SimpleUrlHandlerMapping-与-HttpRequestHandlerAdapter" class="headerlink" title="35) SimpleUrlHandlerMapping 与 HttpRequestHandlerAdapter"></a>35) SimpleUrlHandlerMapping 与 HttpRequestHandlerAdapter</h3><h4 id="演示1-本组映射器和适配器"><a href="#演示1-本组映射器和适配器" class="headerlink" title="演示1 - 本组映射器和适配器"></a>演示1 - 本组映射器和适配器</h4><h5 id="代码参考-39"><a href="#代码参考-39" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>org.springframework.boot.autoconfigure.web.servlet.A35</strong></p>
<h5 id="关键代码-5"><a href="#关键代码-5" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title function_">simpleUrlHandlerMapping</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="type">SimpleUrlHandlerMapping</span> <span class="variable">handlerMapping</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleUrlHandlerMapping</span>();</span><br><span class="line">    Map&lt;String, ResourceHttpRequestHandler&gt; map </span><br><span class="line">        = context.getBeansOfType(ResourceHttpRequestHandler.class);</span><br><span class="line">    handlerMapping.setUrlMap(map);</span><br><span class="line">    <span class="keyword">return</span> handlerMapping;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> HttpRequestHandlerAdapter <span class="title function_">httpRequestHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpRequestHandlerAdapter</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;/**&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title function_">handler1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ResourceHttpRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceHttpRequestHandler</span>();</span><br><span class="line">    handler.setLocations(List.of(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;static/&quot;</span>)));</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;/img/**&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title function_">handler2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ResourceHttpRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceHttpRequestHandler</span>();</span><br><span class="line">    handler.setLocations(List.of(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;images/&quot;</span>)));</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="收获💡-49"><a href="#收获💡-49" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>SimpleUrlHandlerMapping 不会在初始化时收集映射信息，需要手动收集</li>
<li>SimpleUrlHandlerMapping 映射路径</li>
<li>ResourceHttpRequestHandler 作为静态资源 handler</li>
<li>HttpRequestHandlerAdapter, 调用此 handler</li>
</ol>
<h4 id="演示2-静态资源解析优化"><a href="#演示2-静态资源解析优化" class="headerlink" title="演示2 - 静态资源解析优化"></a>演示2 - 静态资源解析优化</h4><h5 id="关键代码-6"><a href="#关键代码-6" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;/**&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title function_">handler1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ResourceHttpRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceHttpRequestHandler</span>();</span><br><span class="line">    handler.setLocations(List.of(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;static/&quot;</span>)));</span><br><span class="line">    handler.setResourceResolvers(List.of(</span><br><span class="line">        	<span class="comment">// ⬇️缓存优化</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CachingResourceResolver</span>(<span class="keyword">new</span> <span class="title class_">ConcurrentMapCache</span>(<span class="string">&quot;cache1&quot;</span>)),</span><br><span class="line">        	<span class="comment">// ⬇️压缩优化</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EncodedResourceResolver</span>(),</span><br><span class="line">        	<span class="comment">// ⬇️原始资源解析</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathResourceResolver</span>()</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="收获💡-50"><a href="#收获💡-50" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>责任链模式体现</li>
<li>压缩文件需要手动生成</li>
</ol>
<h4 id="演示3-欢迎页"><a href="#演示3-欢迎页" class="headerlink" title="演示3 - 欢迎页"></a>演示3 - 欢迎页</h4><h5 id="关键代码-7"><a href="#关键代码-7" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title function_">welcomePageHandlerMapping</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> context.getResource(<span class="string">&quot;classpath:static/index.html&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WelcomePageHandlerMapping</span>(<span class="literal">null</span>, context, resource, <span class="string">&quot;/**&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SimpleControllerHandlerAdapter <span class="title function_">simpleControllerHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleControllerHandlerAdapter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="收获💡-51"><a href="#收获💡-51" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>欢迎页支持静态欢迎页与动态欢迎页</li>
<li>WelcomePageHandlerMapping 映射欢迎页（即只映射 ‘&#x2F;‘）<ul>
<li>它内置的 handler ParameterizableViewController 作用是不执行逻辑，仅根据视图名找视图</li>
<li>视图名固定为 forward:index.html</li>
</ul>
</li>
<li>SimpleControllerHandlerAdapter, 调用 handler<ul>
<li>转发至 &#x2F;index.html</li>
<li>处理 &#x2F;index.html 又会走上面的静态资源处理流程</li>
</ul>
</li>
</ol>
<h4 id="映射器与适配器小结"><a href="#映射器与适配器小结" class="headerlink" title="映射器与适配器小结"></a>映射器与适配器小结</h4><ol>
<li>HandlerMapping 负责建立请求与控制器之间的映射关系<ul>
<li>RequestMappingHandlerMapping (与 @RequestMapping 匹配)</li>
<li>WelcomePageHandlerMapping    (&#x2F;)</li>
<li>BeanNameUrlHandlerMapping    (与 bean 的名字匹配 以 &#x2F; 开头)</li>
<li>RouterFunctionMapping        (函数式 RequestPredicate, HandlerFunction)</li>
<li>SimpleUrlHandlerMapping      (静态资源 通配符 &#x2F;** &#x2F;img&#x2F;**)</li>
<li>之间也会有顺序问题, boot 中默认顺序如上</li>
</ul>
</li>
<li>HandlerAdapter 负责实现对各种各样的 handler 的适配调用<ul>
<li>RequestMappingHandlerAdapter 处理：@RequestMapping 方法<ul>
<li>参数解析器、返回值处理器体现了组合模式</li>
</ul>
</li>
<li>SimpleControllerHandlerAdapter 处理：Controller 接口</li>
<li>HandlerFunctionAdapter 处理：HandlerFunction 函数式接口</li>
<li>HttpRequestHandlerAdapter 处理：HttpRequestHandler 接口 (静态资源处理)</li>
<li>这也是典型适配器模式体现</li>
</ul>
</li>
</ol>
<h3 id="36-mvc-处理流程"><a href="#36-mvc-处理流程" class="headerlink" title="36) mvc 处理流程"></a>36) mvc 处理流程</h3><p>当浏览器发送一个请求 <code>http://localhost:8080/hello</code> 后，请求到达服务器，其处理流程是：</p>
<ol>
<li><p>服务器提供了 DispatcherServlet，它使用的是标准 Servlet 技术</p>
<ul>
<li>路径：默认映射路径为 <code>/</code>，即会匹配到所有请求 URL，可作为请求的统一入口，也被称之为<strong>前控制器</strong><ul>
<li>jsp 不会匹配到 DispatcherServlet</li>
<li>其它有路径的 Servlet 匹配优先级也高于 DispatcherServlet</li>
</ul>
</li>
<li>创建：在 Boot 中，由 DispatcherServletAutoConfiguration 这个自动配置类提供 DispatcherServlet 的 bean</li>
<li>初始化：DispatcherServlet 初始化时会优先到容器里寻找各种组件，作为它的成员变量<ul>
<li>HandlerMapping，初始化时记录映射关系</li>
<li>HandlerAdapter，初始化时准备参数解析器、返回值处理器、消息转换器</li>
<li>HandlerExceptionResolver，初始化时准备参数解析器、返回值处理器、消息转换器</li>
<li>ViewResolver</li>
</ul>
</li>
</ul>
</li>
<li><p>DispatcherServlet 会利用 RequestMappingHandlerMapping 查找控制器方法</p>
<ul>
<li>例如根据 &#x2F;hello 路径找到 @RequestMapping(“&#x2F;hello”) 对应的控制器方法</li>
<li>控制器方法会被封装为 HandlerMethod 对象，并结合匹配到的拦截器一起返回给 DispatcherServlet</li>
<li>HandlerMethod 和拦截器合在一起称为 HandlerExecutionChain（调用链）对象</li>
</ul>
</li>
<li><p>DispatcherServlet 接下来会：</p>
<ol>
<li>调用拦截器的 preHandle 方法</li>
<li>RequestMappingHandlerAdapter 调用 handle 方法，准备数据绑定工厂、模型工厂、ModelAndViewContainer、将 HandlerMethod 完善为 ServletInvocableHandlerMethod<ul>
<li>@ControllerAdvice 全局增强点1️⃣：补充模型数据</li>
<li>@ControllerAdvice 全局增强点2️⃣：补充自定义类型转换器</li>
<li>使用 HandlerMethodArgumentResolver 准备参数<ul>
<li>@ControllerAdvice 全局增强点3️⃣：RequestBody 增强</li>
</ul>
</li>
<li>调用 ServletInvocableHandlerMethod</li>
<li>使用 HandlerMethodReturnValueHandler 处理返回值<ul>
<li>@ControllerAdvice 全局增强点4️⃣：ResponseBody 增强</li>
</ul>
</li>
<li>根据 ModelAndViewContainer 获取 ModelAndView<ul>
<li>如果返回的 ModelAndView 为 null，不走第 4 步视图解析及渲染流程<ul>
<li>例如，有的返回值处理器调用了 HttpMessageConverter 来将结果转换为 JSON，这时 ModelAndView 就为 null</li>
</ul>
</li>
<li>如果返回的 ModelAndView 不为 null，会在第 4 步走视图解析及渲染流程</li>
</ul>
</li>
</ul>
</li>
<li>调用拦截器的 postHandle 方法</li>
<li>处理异常或视图渲染<ul>
<li>如果 1~3 出现异常，走 ExceptionHandlerExceptionResolver 处理异常流程<ul>
<li>@ControllerAdvice 全局增强点5️⃣：@ExceptionHandler 异常处理</li>
</ul>
</li>
<li>正常，走视图解析及渲染流程</li>
</ul>
</li>
<li>调用拦截器的 afterCompletion 方法</li>
</ol>
</li>
</ol>
<h2 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h2><h3 id="37-Boot-骨架项目"><a href="#37-Boot-骨架项目" class="headerlink" title="37) Boot 骨架项目"></a>37) Boot 骨架项目</h3><p>如果是 linux 环境，用以下命令即可获取 spring boot 的骨架 pom.xml</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G https://start.spring.io/pom.xml -d dependencies=web,mysql,mybatis -o pom.xml</span><br></pre></td></tr></table></figure>

<p>也可以使用 Postman 等工具实现</p>
<p>若想获取更多用法，请参考</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://start.spring.io</span><br></pre></td></tr></table></figure>

<h3 id="38-Boot-War项目"><a href="#38-Boot-War项目" class="headerlink" title="38) Boot War项目"></a>38) Boot War项目</h3><p>步骤1：创建模块，区别在于打包方式选择 war</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://upyun.goku.top/blog/error.jpg&quot;" data-lazy-src="https://ghproxy.com/https://raw.githubusercontent.com/sgr997/images/main/itheima_spring50/image-20211021160145072.png" alt="image-20211021160145072" style="zoom: 50%;" />

<p>接下来勾选 Spring Web 支持</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://upyun.goku.top/blog/error.jpg&quot;" data-lazy-src="https://ghproxy.com/https://raw.githubusercontent.com/sgr997/images/main/itheima_spring50/image-20211021162416525.png" alt="image-20211021162416525" style="zoom:50%;" />

<p>步骤2：编写控制器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">abc</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入了控制器&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤3：编写 jsp 视图，新建 webapp 目录和一个 hello.jsp 文件，注意文件名与控制器方法返回的视图逻辑名一致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">	|- main</span><br><span class="line">		|- java</span><br><span class="line">		|- resources</span><br><span class="line">		|- webapp</span><br><span class="line">			|- hello.jsp</span><br></pre></td></tr></table></figure>

<p>步骤4：配置视图路径，打开 application.properties 文件</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/</span></span><br><span class="line"><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>将来 prefix + 控制器方法返回值 + suffix 即为视图完整路径</p>
</blockquote>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>如果用 mvn 插件 <code>mvn spring-boot:run</code> 或 main 方法测试</p>
<ul>
<li>必须添加如下依赖，因为此时用的还是内嵌 tomcat，而内嵌 tomcat 默认不带 jasper（用来解析 jsp）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以使用 Idea 配置 tomcat 来测试，此时用的是外置 tomcat</p>
<ul>
<li>骨架生成的代码中，多了一个 ServletInitializer，它的作用就是配置外置 Tomcat 使用的，在外置 Tomcat 启动后，去调用它创建和运行 SpringApplication</li>
</ul>
<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>对于 jar 项目，若要支持 jsp，也可以在加入 jasper 依赖的前提下，把 jsp 文件置入 <code>META-INF/resources</code></p>
<h3 id="39-Boot-启动过程"><a href="#39-Boot-启动过程" class="headerlink" title="39) Boot 启动过程"></a>39) Boot 启动过程</h3><p>阶段一：SpringApplication 构造</p>
<ol>
<li>记录 BeanDefinition 源</li>
<li>推断应用类型</li>
<li>记录 ApplicationContext 初始化器</li>
<li>记录监听器</li>
<li>推断主启动类</li>
</ol>
<p>阶段二：执行 run 方法</p>
<ol>
<li><p>得到 SpringApplicationRunListeners，名字取得不好，实际是事件发布器</p>
<ul>
<li>发布 application starting 事件1️⃣</li>
</ul>
</li>
<li><p>封装启动 args</p>
</li>
<li><p>准备 Environment 添加命令行参数（*）</p>
</li>
<li><p>ConfigurationPropertySources 处理（*）</p>
<ul>
<li>发布 application environment 已准备事件2️⃣</li>
</ul>
</li>
<li><p>通过 EnvironmentPostProcessorApplicationListener 进行 env 后处理（*）</p>
<ul>
<li>application.properties，由 StandardConfigDataLocationResolver 解析</li>
<li>spring.application.json</li>
</ul>
</li>
<li><p>绑定 spring.main 到 SpringApplication 对象（*）</p>
</li>
<li><p>打印 banner（*）</p>
</li>
<li><p>创建容器</p>
</li>
<li><p>准备容器</p>
<ul>
<li>发布 application context 已初始化事件3️⃣</li>
</ul>
</li>
<li><p>加载 bean 定义</p>
<ul>
<li>发布 application prepared 事件4️⃣</li>
</ul>
</li>
<li><p>refresh 容器</p>
<ul>
<li>发布 application started 事件5️⃣</li>
</ul>
</li>
<li><p>执行 runner</p>
<ul>
<li>发布 application ready 事件6️⃣</li>
<li>这其中有异常，发布 application failed 事件7️⃣</li>
</ul>
</li>
</ol>
<blockquote>
<p>带 * 的有独立的示例</p>
</blockquote>
<h4 id="演示-启动过程"><a href="#演示-启动过程" class="headerlink" title="演示 - 启动过程"></a>演示 - 启动过程</h4><p><strong>com.itheima.a39.A39_1</strong> 对应 SpringApplication 构造</p>
<p><strong>com.itheima.a39.A39_2</strong> 对应第1步，并演示 7 个事件</p>
<p><strong>com.itheima.a39.A39_3</strong> 对应第2、8到12步</p>
<p><strong>org.springframework.boot.Step3</strong></p>
<p><strong>org.springframework.boot.Step4</strong></p>
<p><strong>org.springframework.boot.Step5</strong></p>
<p><strong>org.springframework.boot.Step6</strong></p>
<p><strong>org.springframework.boot.Step7</strong></p>
<h4 id="收获💡-52"><a href="#收获💡-52" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>SpringApplication 构造方法中所做的操作<ul>
<li>可以有多种源用来加载 bean 定义</li>
<li>应用类型推断</li>
<li>添加容器初始化器</li>
<li>添加监听器</li>
<li>演示主类推断</li>
</ul>
</li>
<li>如何读取 spring.factories 中的配置</li>
<li>从配置中获取重要的事件发布器：SpringApplicationRunListeners</li>
<li>容器的创建、初始化器增强、加载 bean 定义等</li>
<li>CommandLineRunner、ApplicationRunner 的作用</li>
<li>环境对象<ol>
<li>命令行 PropertySource</li>
<li>ConfigurationPropertySources 规范环境键名称</li>
<li>EnvironmentPostProcessor 后处理增强<ul>
<li>由 EventPublishingRunListener 通过监听事件2️⃣来调用</li>
</ul>
</li>
<li>绑定 spring.main 前缀的 key value 至 SpringApplication</li>
</ol>
</li>
<li>Banner</li>
</ol>
<h3 id="40-Tomcat-内嵌容器"><a href="#40-Tomcat-内嵌容器" class="headerlink" title="40) Tomcat 内嵌容器"></a>40) Tomcat 内嵌容器</h3><p>Tomcat 基本结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Server</span><br><span class="line">└───Service</span><br><span class="line">    ├───Connector (协议, 端口)</span><br><span class="line">    └───Engine</span><br><span class="line">        └───Host(虚拟主机 localhost)</span><br><span class="line">            ├───Context1 (应用1, 可以设置虚拟路径, / 即 url 起始路径; 项目磁盘路径, 即 docBase )</span><br><span class="line">            │   │   index.html</span><br><span class="line">            │   └───WEB-INF</span><br><span class="line">            │       │   web.xml (servlet, filter, listener) 3.0</span><br><span class="line">            │       ├───classes (servlet, controller, service ...)</span><br><span class="line">            │       ├───jsp</span><br><span class="line">            │       └───lib (第三方 jar 包)</span><br><span class="line">            └───Context2 (应用2)</span><br><span class="line">                │   index.html</span><br><span class="line">                └───WEB-INF</span><br><span class="line">                        web.xml</span><br></pre></td></tr></table></figure>

<h4 id="演示1-Tomcat-内嵌容器"><a href="#演示1-Tomcat-内嵌容器" class="headerlink" title="演示1 - Tomcat 内嵌容器"></a>演示1 - Tomcat 内嵌容器</h4><h5 id="关键代码-8"><a href="#关键代码-8" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> LifecycleException, IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建 Tomcat 对象</span></span><br><span class="line">    <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">    tomcat.setBaseDir(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建项目文件夹, 即 docBase 文件夹</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">docBase</span> <span class="operator">=</span> Files.createTempDirectory(<span class="string">&quot;boot.&quot;</span>).toFile();</span><br><span class="line">    docBase.deleteOnExit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建 Tomcat 项目, 在 Tomcat 中称为 Context</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> tomcat.addContext(<span class="string">&quot;&quot;</span>, docBase.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.编程添加 Servlet</span></span><br><span class="line">    context.addServletContainerInitializer(<span class="keyword">new</span> <span class="title class_">ServletContainerInitializer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">            <span class="type">HelloServlet</span> <span class="variable">helloServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServlet</span>();</span><br><span class="line">            ctx.addServlet(<span class="string">&quot;aaa&quot;</span>, helloServlet).addMapping(<span class="string">&quot;/hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, Collections.emptySet());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.启动 Tomcat</span></span><br><span class="line">    tomcat.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.创建连接器, 设置监听端口</span></span><br><span class="line">    <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>(<span class="keyword">new</span> <span class="title class_">Http11Nio2Protocol</span>());</span><br><span class="line">    connector.setPort(<span class="number">8080</span>);</span><br><span class="line">    tomcat.setConnector(connector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="演示2-集成-Spring-容器"><a href="#演示2-集成-Spring-容器" class="headerlink" title="演示2 - 集成 Spring 容器"></a>演示2 - 集成 Spring 容器</h4><h5 id="关键代码-9"><a href="#关键代码-9" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebApplicationContext</span> <span class="variable">springContext</span> <span class="operator">=</span> getApplicationContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.编程添加 Servlet</span></span><br><span class="line">context.addServletContainerInitializer(<span class="keyword">new</span> <span class="title class_">ServletContainerInitializer</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// ⬇️通过 ServletRegistrationBean 添加 DispatcherServlet 等</span></span><br><span class="line">        <span class="keyword">for</span> (ServletRegistrationBean registrationBean : </span><br><span class="line">             springContext.getBeansOfType(ServletRegistrationBean.class).values()) &#123;</span><br><span class="line">            registrationBean.onStartup(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, Collections.emptySet());</span><br></pre></td></tr></table></figure>

<h3 id="41-Boot-自动配置"><a href="#41-Boot-自动配置" class="headerlink" title="41) Boot 自动配置"></a>41) Boot 自动配置</h3><h4 id="AopAutoConfiguration"><a href="#AopAutoConfiguration" class="headerlink" title="AopAutoConfiguration"></a>AopAutoConfiguration</h4><p>Spring Boot 是利用了自动配置类来简化了 aop 相关配置</p>
<ul>
<li>AOP 自动配置类为 <code>org.springframework.boot.autoconfigure.aop.AopAutoConfiguration</code></li>
<li>可以通过 <code>spring.aop.auto=false</code> 禁用 aop 自动配置</li>
<li>AOP 自动配置的本质是通过 <code>@EnableAspectJAutoProxy</code> 来开启了自动代理，如果在引导类上自己添加了 <code>@EnableAspectJAutoProxy</code> 那么以自己添加的为准</li>
<li><code>@EnableAspectJAutoProxy</code> 的本质是向容器中添加了 <code>AnnotationAwareAspectJAutoProxyCreator</code> 这个 bean 后处理器，它能够找到容器中所有切面，并为匹配切点的目标类创建代理，创建代理的工作一般是在 bean 的初始化阶段完成的</li>
</ul>
<h4 id="DataSourceAutoConfiguration"><a href="#DataSourceAutoConfiguration" class="headerlink" title="DataSourceAutoConfiguration"></a>DataSourceAutoConfiguration</h4><ul>
<li>对应的自动配置类为：org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</li>
<li>它内部采用了条件装配，通过检查容器的 bean，以及类路径下的 class，来决定该 @Bean 是否生效</li>
</ul>
<p>简单说明一下，Spring Boot 支持两大类数据源：</p>
<ul>
<li>EmbeddedDatabase - 内嵌数据库连接池</li>
<li>PooledDataSource - 非内嵌数据库连接池</li>
</ul>
<p>PooledDataSource 又支持如下数据源</p>
<ul>
<li>hikari 提供的 HikariDataSource</li>
<li>tomcat-jdbc 提供的 DataSource</li>
<li>dbcp2 提供的 BasicDataSource</li>
<li>oracle 提供的 PoolDataSourceImpl</li>
</ul>
<p>如果知道数据源的实现类类型，即指定了 <code>spring.datasource.type</code>，理论上可以支持所有数据源，但这样做的一个最大问题是无法订制每种数据源的详细配置（如最大、最小连接数等）</p>
<h4 id="MybatisAutoConfiguration"><a href="#MybatisAutoConfiguration" class="headerlink" title="MybatisAutoConfiguration"></a>MybatisAutoConfiguration</h4><ul>
<li>MyBatis 自动配置类为 <code>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</code></li>
<li>它主要配置了两个 bean<ul>
<li>SqlSessionFactory - MyBatis 核心对象，用来创建 SqlSession</li>
<li>SqlSessionTemplate - SqlSession 的实现，此实现会与当前线程绑定</li>
<li>用 ImportBeanDefinitionRegistrar 的方式扫描所有标注了 @Mapper 注解的接口</li>
<li>用 AutoConfigurationPackages 来确定扫描的包</li>
</ul>
</li>
<li>还有一个相关的 bean：MybatisProperties，它会读取配置文件中带 <code>mybatis.</code> 前缀的配置项进行定制配置</li>
</ul>
<p>@MapperScan 注解的作用与 MybatisAutoConfiguration 类似，会注册 MapperScannerConfigurer 有如下区别</p>
<ul>
<li>@MapperScan 扫描具体包（当然也可以配置关注哪个注解）</li>
<li>@MapperScan 如果不指定扫描具体包，则会把引导类范围内，所有接口当做 Mapper 接口</li>
<li>MybatisAutoConfiguration 关注的是所有标注 @Mapper 注解的接口，会忽略掉非 @Mapper 标注的接口</li>
</ul>
<p>这里有同学有疑问，之前介绍的都是将具体类交给 Spring 管理，怎么到了 MyBatis 这儿，接口就可以被管理呢？</p>
<ul>
<li>其实并非将接口交给 Spring 管理，而是每个接口会对应一个 MapperFactoryBean，是后者被 Spring 所管理，接口只是作为 MapperFactoryBean 的一个属性来配置</li>
</ul>
<h4 id="TransactionAutoConfiguration"><a href="#TransactionAutoConfiguration" class="headerlink" title="TransactionAutoConfiguration"></a>TransactionAutoConfiguration</h4><ul>
<li><p>事务自动配置类有两个：</p>
<ul>
<li><code>org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration</code></li>
<li><code>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration</code></li>
</ul>
</li>
<li><p>前者配置了 DataSourceTransactionManager 用来执行事务的提交、回滚操作</p>
</li>
<li><p>后者功能上对标 @EnableTransactionManagement，包含以下三个 bean</p>
<ul>
<li>BeanFactoryTransactionAttributeSourceAdvisor 事务切面类，包含通知和切点</li>
<li>TransactionInterceptor 事务通知类，由它在目标方法调用前后加入事务操作</li>
<li>AnnotationTransactionAttributeSource 会解析 @Transactional 及事务属性，也包含了切点功能</li>
</ul>
</li>
<li><p>如果自己配置了 DataSourceTransactionManager 或是在引导类加了 @EnableTransactionManagement，则以自己配置的为准</p>
</li>
</ul>
<h4 id="ServletWebServerFactoryAutoConfiguration"><a href="#ServletWebServerFactoryAutoConfiguration" class="headerlink" title="ServletWebServerFactoryAutoConfiguration"></a>ServletWebServerFactoryAutoConfiguration</h4><ul>
<li>提供 ServletWebServerFactory</li>
</ul>
<h4 id="DispatcherServletAutoConfiguration"><a href="#DispatcherServletAutoConfiguration" class="headerlink" title="DispatcherServletAutoConfiguration"></a>DispatcherServletAutoConfiguration</h4><ul>
<li>提供 DispatcherServlet</li>
<li>提供 DispatcherServletRegistrationBean</li>
</ul>
<h4 id="WebMvcAutoConfiguration"><a href="#WebMvcAutoConfiguration" class="headerlink" title="WebMvcAutoConfiguration"></a>WebMvcAutoConfiguration</h4><ul>
<li>配置 DispatcherServlet 的各项组件，提供的 bean 见过的有<ul>
<li>多项 HandlerMapping</li>
<li>多项 HandlerAdapter</li>
<li>HandlerExceptionResolver</li>
</ul>
</li>
</ul>
<h4 id="ErrorMvcAutoConfiguration"><a href="#ErrorMvcAutoConfiguration" class="headerlink" title="ErrorMvcAutoConfiguration"></a>ErrorMvcAutoConfiguration</h4><ul>
<li>提供的 bean 有 BasicErrorController</li>
</ul>
<h4 id="MultipartAutoConfiguration"><a href="#MultipartAutoConfiguration" class="headerlink" title="MultipartAutoConfiguration"></a>MultipartAutoConfiguration</h4><ul>
<li>它提供了 org.springframework.web.multipart.support.StandardServletMultipartResolver</li>
<li>该 bean 用来解析 multipart&#x2F;form-data 格式的数据</li>
</ul>
<h4 id="HttpEncodingAutoConfiguration"><a href="#HttpEncodingAutoConfiguration" class="headerlink" title="HttpEncodingAutoConfiguration"></a>HttpEncodingAutoConfiguration</h4><ul>
<li>POST 请求参数如果有中文，无需特殊设置，这是因为 Spring Boot 已经配置了 org.springframework.boot.web.servlet.filter.OrderedCharacterEncodingFilter</li>
<li>对应配置 server.servlet.encoding.charset&#x3D;UTF-8，默认就是 UTF-8</li>
<li>当然，它只影响非 json 格式的数据</li>
</ul>
<h4 id="演示-自动配置类原理"><a href="#演示-自动配置类原理" class="headerlink" title="演示 - 自动配置类原理"></a>演示 - 自动配置类原理</h4><h5 id="关键代码-10"><a href="#关键代码-10" class="headerlink" title="关键代码"></a>关键代码</h5><p>假设已有第三方的两个自动配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// ⬅️第三方的配置类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// ⬅️第三方的配置类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration2</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供一个配置文件 META-INF&#x2F;spring.factories，key 为导入器类名，值为多个自动配置类名，用逗号分隔</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">MyImportSelector</span>=<span class="string">\</span></span><br><span class="line"><span class="string">AutoConfiguration1,\</span></span><br><span class="line"><span class="string">AutoConfiguration2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><em><strong>注意</strong></em></p>
<ul>
<li>上述配置文件中 MyImportSelector 与 AutoConfiguration1，AutoConfiguration2 为简洁均省略了包名，自己测试时请将包名根据情况补全</li>
</ul>
</blockquote>
<p>引入自动配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// ⬅️本项目的配置类</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> &#123;</span><br><span class="line">    <span class="comment">// ⬇️该方法从 META-INF/spring.factories 读取自动配置类名，返回的 String[] 即为要导入的配置类</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> SpringFactoriesLoader</span><br><span class="line">            .loadFactoryNames(MyImportSelector.class, <span class="literal">null</span>).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="收获💡-53"><a href="#收获💡-53" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>自动配置类本质上就是一个配置类而已，只是用 META-INF&#x2F;spring.factories 管理，与应用配置类解耦</li>
<li>@Enable 打头的注解本质是利用了 @Import</li>
<li>@Import 配合 DeferredImportSelector 即可实现导入，selectImports 方法的返回值即为要导入的配置类名</li>
<li>DeferredImportSelector 的导入会在最后执行，为的是让其它配置优先解析</li>
</ol>
<h3 id="42-条件装配底层"><a href="#42-条件装配底层" class="headerlink" title="42) 条件装配底层"></a>42) 条件装配底层</h3><p>条件装配的底层是本质上是 @Conditional 与 Condition，这两个注解。引入自动配置类时，期望满足一定条件才能被 Spring 管理，不满足则不管理，怎么做呢？</p>
<p>比如条件是【类路径下必须有 dataSource】这个 bean ，怎么做呢？</p>
<p>首先编写条件判断类，它实现 Condition 接口，编写条件判断逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyCondition1</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123; </span><br><span class="line">    <span class="comment">// ⬇️如果存在 Druid 依赖，条件成立</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ClassUtils.isPresent(<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，在要导入的自动配置类上添加 <code>@Conditional(MyCondition1.class)</code>，将来此类被导入时就会做条件检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 第三方的配置类</span></span><br><span class="line"><span class="meta">@Conditional(MyCondition1.class)</span> <span class="comment">// ⬅️加入条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别测试加入和去除 druid 依赖，观察 bean1 是否存在于容器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="收获💡-54"><a href="#收获💡-54" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>学习一种特殊的 if - else</li>
</ol>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="43-FactoryBean"><a href="#43-FactoryBean" class="headerlink" title="43) FactoryBean"></a>43) FactoryBean</h3><h4 id="演示-FactoryBean"><a href="#演示-FactoryBean" class="headerlink" title="演示 - FactoryBean"></a>演示 - FactoryBean</h4><h5 id="代码参考-40"><a href="#代码参考-40" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a43</strong> 包</p>
<h4 id="收获💡-55"><a href="#收获💡-55" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>它的作用是用制造创建过程较为复杂的产品, 如 SqlSessionFactory, 但 @Bean 已具备等价功能</li>
<li>使用上较为古怪, 一不留神就会用错<ol>
<li>被 FactoryBean 创建的产品<ul>
<li>会认为创建、依赖注入、Aware 接口回调、前初始化这些都是 FactoryBean 的职责, 这些流程都不会走</li>
<li>唯有后初始化的流程会走, 也就是产品可以被代理增强</li>
<li>单例的产品不会存储于 BeanFactory 的 singletonObjects 成员中, 而是另一个 factoryBeanObjectCache 成员中</li>
</ul>
</li>
<li>按名字去获取时, 拿到的是产品对象, 名字前面加 &amp; 获取的是工厂对象</li>
</ol>
</li>
</ol>
<h3 id="44-Indexed-原理"><a href="#44-Indexed-原理" class="headerlink" title="44) @Indexed 原理"></a>44) @Indexed 原理</h3><p>真实项目中，只需要加入以下依赖即可</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-indexer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="演示-Indexed"><a href="#演示-Indexed" class="headerlink" title="演示 - @Indexed"></a>演示 - @Indexed</h4><h5 id="代码参考-41"><a href="#代码参考-41" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a44</strong> 包</p>
<h4 id="收获💡-56"><a href="#收获💡-56" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>在编译时就根据 @Indexed 生成 META-INF&#x2F;spring.components 文件</li>
<li>扫描时<ul>
<li>如果发现 META-INF&#x2F;spring.components 存在, 以它为准加载 bean definition</li>
<li>否则, 会遍历包下所有 class 资源 (包括 jar 内的)</li>
</ul>
</li>
<li>解决的问题，在编译期就找到 @Component 组件，节省运行期间扫描 @Component 的时间</li>
</ol>
<h3 id="45-代理进一步理解"><a href="#45-代理进一步理解" class="headerlink" title="45) 代理进一步理解"></a>45) 代理进一步理解</h3><h4 id="演示-代理"><a href="#演示-代理" class="headerlink" title="演示 - 代理"></a>演示 - 代理</h4><h5 id="代码参考-42"><a href="#代码参考-42" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a45</strong> 包</p>
<h4 id="收获💡-57"><a href="#收获💡-57" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li><p>spring 代理的设计特点</p>
<ul>
<li><p>依赖注入和初始化影响的是原始对象</p>
<ul>
<li>因此 cglib 不能用 MethodProxy.invokeSuper()</li>
</ul>
</li>
<li><p>代理与目标是两个对象，二者成员变量并不共用数据</p>
</li>
</ul>
</li>
<li><p>static 方法、final 方法、private 方法均无法增强</p>
<ul>
<li>进一步理解代理增强基于方法重写</li>
</ul>
</li>
</ol>
<h3 id="46-Value-装配底层"><a href="#46-Value-装配底层" class="headerlink" title="46) @Value 装配底层"></a>46) @Value 装配底层</h3><h4 id="按类型装配的步骤"><a href="#按类型装配的步骤" class="headerlink" title="按类型装配的步骤"></a>按类型装配的步骤</h4><ol>
<li>查看需要的类型是否为 Optional，是，则进行封装（非延迟），否则向下走</li>
<li>查看需要的类型是否为 ObjectFactory 或 ObjectProvider，是，则进行封装（延迟），否则向下走</li>
<li>查看需要的类型（成员或参数）上是否用 @Lazy 修饰，是，则返回代理，否则向下走</li>
<li>解析 @Value 的值<ol>
<li>如果需要的值是字符串，先解析 ${ }，再解析 #{ }</li>
<li>不是字符串，需要用 TypeConverter 转换</li>
</ol>
</li>
<li>看需要的类型是否为 Stream、Array、Collection、Map，是，则按集合处理，否则向下走</li>
<li>在 BeanFactory 的 resolvableDependencies 中找有没有类型合适的对象注入，没有向下走</li>
<li>在 BeanFactory 及父工厂中找类型匹配的 bean 进行筛选，筛选时会考虑 @Qualifier 及泛型</li>
<li>结果个数为 0 抛出 NoSuchBeanDefinitionException 异常</li>
<li>如果结果 &gt; 1，再根据 @Primary 进行筛选</li>
<li>如果结果仍 &gt; 1，再根据成员名或变量名进行筛选</li>
<li>结果仍 &gt; 1，抛出 NoUniqueBeanDefinitionException 异常</li>
</ol>
<h4 id="演示-Value-装配过程"><a href="#演示-Value-装配过程" class="headerlink" title="演示 - @Value 装配过程"></a>演示 - @Value 装配过程</h4><h5 id="代码参考-43"><a href="#代码参考-43" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a46</strong> 包</p>
<h4 id="收获💡-58"><a href="#收获💡-58" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>ContextAnnotationAutowireCandidateResolver 作用之一，获取 @Value 的值</li>
<li>了解 ${ } 对应的解析器</li>
<li>了解 #{ } 对应的解析器</li>
<li>TypeConvert 的一项体现</li>
</ol>
<h3 id="47-Autowired-装配底层"><a href="#47-Autowired-装配底层" class="headerlink" title="47) @Autowired 装配底层"></a>47) @Autowired 装配底层</h3><h4 id="演示-Autowired-装配过程"><a href="#演示-Autowired-装配过程" class="headerlink" title="演示 - @Autowired 装配过程"></a>演示 - @Autowired 装配过程</h4><h5 id="代码参考-44"><a href="#代码参考-44" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a47</strong> 包</p>
<h4 id="收获💡-59"><a href="#收获💡-59" class="headerlink" title="收获💡"></a>收获💡</h4><ol>
<li>@Autowired 本质上是根据成员变量或方法参数的类型进行装配</li>
<li>如果待装配类型是 Optional，需要根据 Optional 泛型找到 bean，再封装为 Optional 对象装配</li>
<li>如果待装配的类型是 ObjectFactory，需要根据 ObjectFactory 泛型创建 ObjectFactory 对象装配<ul>
<li>此方法可以延迟 bean 的获取</li>
</ul>
</li>
<li>如果待装配的成员变量或方法参数上用 @Lazy 标注，会创建代理对象装配<ul>
<li>此方法可以延迟真实 bean 的获取</li>
<li>被装配的代理不作为 bean</li>
</ul>
</li>
<li>如果待装配类型是数组，需要获取数组元素类型，根据此类型找到多个 bean 进行装配</li>
<li>如果待装配类型是 Collection 或其子接口，需要获取 Collection 泛型，根据此类型找到多个 bean</li>
<li>如果待装配类型是 ApplicationContext 等特殊类型<ul>
<li>会在 BeanFactory 的 resolvableDependencies 成员按类型查找装配</li>
<li>resolvableDependencies 是 map 集合，key 是特殊类型，value 是其对应对象</li>
<li>不能直接根据 key 进行查找，而是用 isAssignableFrom 逐一尝试右边类型是否可以被赋值给左边的 key 类型</li>
</ul>
</li>
<li>如果待装配类型有泛型参数<ul>
<li>需要利用 ContextAnnotationAutowireCandidateResolver 按泛型参数类型筛选</li>
</ul>
</li>
<li>如果待装配类型有 @Qualifier<ul>
<li>需要利用 ContextAnnotationAutowireCandidateResolver 按注解提供的 bean 名称筛选</li>
</ul>
</li>
<li>有 @Primary 标注的 @Component 或 @Bean 的处理</li>
<li>与成员变量名或方法参数名同名 bean 的处理</li>
</ol>
<h3 id="48-事件监听器"><a href="#48-事件监听器" class="headerlink" title="48) 事件监听器"></a>48) 事件监听器</h3><h4 id="演示-事件监听器"><a href="#演示-事件监听器" class="headerlink" title="演示 - 事件监听器"></a>演示 - 事件监听器</h4><h5 id="代码参考-45"><a href="#代码参考-45" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a48</strong> 包</p>
<h4 id="收获💡-60"><a href="#收获💡-60" class="headerlink" title="收获💡"></a>收获💡</h4><p>事件监听器的两种方式</p>
<ol>
<li>实现 ApplicationListener 接口<ul>
<li>根据接口泛型确定事件类型</li>
</ul>
</li>
<li>@EventListener 标注监听方法<ul>
<li>根据监听器方法参数确定事件类型</li>
<li>解析时机：在 SmartInitializingSingleton（所有单例初始化完成后），解析每个单例 bean</li>
</ul>
</li>
</ol>
<h3 id="49-事件发布器"><a href="#49-事件发布器" class="headerlink" title="49) 事件发布器"></a>49) 事件发布器</h3><h4 id="演示-事件发布器"><a href="#演示-事件发布器" class="headerlink" title="演示 - 事件发布器"></a>演示 - 事件发布器</h4><h5 id="代码参考-46"><a href="#代码参考-46" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a49</strong> 包</p>
<h4 id="收获💡-61"><a href="#收获💡-61" class="headerlink" title="收获💡"></a>收获💡</h4><p>事件发布器模拟实现</p>
<ol>
<li>addApplicationListenerBean 负责收集容器中的监听器<ul>
<li>监听器会统一转换为 GenericApplicationListener 对象，以支持判断事件类型</li>
</ul>
</li>
<li>multicastEvent 遍历监听器集合，发布事件<ul>
<li>发布前先通过 GenericApplicationListener.supportsEventType 判断支持该事件类型才发事件</li>
<li>可以利用线程池进行异步发事件优化</li>
</ul>
</li>
<li>如果发送的事件对象不是 ApplicationEvent 类型，Spring 会把它包装为 PayloadApplicationEvent 并用泛型技术解析事件对象的原始类型<ul>
<li>视频中未讲解</li>
</ul>
</li>
</ol>
</article><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/56715.html"><img class="prev-cover" src="https://upyun.goku.top/blog/zj_mt.png" onerror="onerror=null;src='https://upyun.goku.top/blog/error.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">（转载）设计模式二三事</div></div></a></div><div class="next-post pull-right"><a href="/posts/30.html"><img class="next-cover" src="https://upyun.goku.top/blog/netty.png" onerror="onerror=null;src='https://upyun.goku.top/blog/error.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Netty教程-nio</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/8275.html" title="Spring中使用模板方法模式(接上文)"><img class="cover" src="https://upyun.goku.top/blog/post_banner_8.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-12-13</div><div class="title">Spring中使用模板方法模式(接上文)</div></div></a></div><div><a href="/posts/22676.html" title="Spring项目中使用策略模式和工厂模式"><img class="cover" src="https://upyun.goku.top/blog/post_banner_7.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-12-04</div><div class="title">Spring项目中使用策略模式和工厂模式</div></div></a></div><div><a href="/posts/53914.html" title="JVM学习-垃圾回收"><img class="cover" src="https://upyun.goku.top/blog/jvm.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-12-04</div><div class="title">JVM学习-垃圾回收</div></div></a></div><div><a href="/posts/9365.html" title="JVM学习-类加载"><img class="cover" src="https://upyun.goku.top/blog/jvm.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-02-23</div><div class="title">JVM学习-类加载</div></div></a></div><div><a href="/posts/30.html" title="Netty教程-nio"><img class="cover" src="https://upyun.goku.top/blog/netty.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-04-11</div><div class="title">Netty教程-nio</div></div></a></div><div><a href="/posts/47670.html" title="Netty教程-优化与源码"><img class="cover" src="https://upyun.goku.top/blog/netty.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-04-11</div><div class="title">Netty教程-优化与源码</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src="https://upyun.goku.top/white/avatar.JPG" onerror="this.onerror=null;this.src='https://upyun.goku.top/blog/error.jpg'" alt="avatar"/><div class="author-status"><img class="g-status" src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);"><b style="color:#fff;font-size:25px">感谢</b>你能在茫茫互联网中访问到小小的本站，希望你可以在本站有所收获，enjoy😊!本站域名<b style="color:#fff">goku.top</b>取自我最喜爱的动漫七龙珠中的人物<b style="color:#fff">狗空(孙悟空)</b>的英文名<b style="color:#fff">goku</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Pei</h1><div class="author-info__desc">花有重开日，人无再少年</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/sgr997" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/49499302" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8E-bean"><span class="toc-number">1.</span> <span class="toc-text">容器与 bean</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%B9%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.</span> <span class="toc-text">1) 容器接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA1-BeanFactory-%E4%B8%8E-ApplicationContext-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.1.</span> <span class="toc-text">演示1 - BeanFactory 与 ApplicationContext 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1"><span class="toc-number">1.1.2.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA2-%E5%9B%BD%E9%99%85%E5%8C%96"><span class="toc-number">1.1.3.</span> <span class="toc-text">演示2 - 国际化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">2) 容器实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA1-DefaultListableBeanFactory"><span class="toc-number">1.2.1.</span> <span class="toc-text">演示1 - DefaultListableBeanFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-1"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA2-%E5%B8%B8%E8%A7%81-ApplicationContext-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">演示2 - 常见 ApplicationContext 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-2"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-2"><span class="toc-number">1.2.4.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.</span> <span class="toc-text">3) Bean 的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA1-bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">演示1 - bean 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-3"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-3"><span class="toc-number">1.3.2.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA2-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">演示2 - 模板方法设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">关键代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA3-bean-%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.4.</span> <span class="toc-text">演示3 - bean 后处理器排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-4"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-4"><span class="toc-number">1.3.5.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Bean-%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">4) Bean 后处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA1-%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">演示1 - 后处理器作用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-5"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-5"><span class="toc-number">1.4.2.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA2-Autowired-bean-%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%90%E8%A1%8C%E5%88%86%E6%9E%90"><span class="toc-number">1.4.3.</span> <span class="toc-text">演示2 - @Autowired bean 后处理器运行分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-6"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-6"><span class="toc-number">1.4.4.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-BeanFactory-%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">5) BeanFactory 后处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA1-BeanFactory-%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">演示1 - BeanFactory 后处理器的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-7"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-7"><span class="toc-number">1.5.2.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA2-%E6%A8%A1%E6%8B%9F%E8%A7%A3%E6%9E%90-ComponentScan"><span class="toc-number">1.5.3.</span> <span class="toc-text">演示2 - 模拟解析 @ComponentScan</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-8"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-8"><span class="toc-number">1.5.4.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA3-%E6%A8%A1%E6%8B%9F%E8%A7%A3%E6%9E%90-Bean"><span class="toc-number">1.5.5.</span> <span class="toc-text">演示3 - 模拟解析 @Bean</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-9"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-9"><span class="toc-number">1.5.6.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA4-%E6%A8%A1%E6%8B%9F%E8%A7%A3%E6%9E%90-Mapper-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.7.</span> <span class="toc-text">演示4 - 模拟解析 Mapper 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-10"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-10"><span class="toc-number">1.5.8.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Aware-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.</span> <span class="toc-text">6) Aware 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-Aware-%E6%8E%A5%E5%8F%A3%E5%8F%8A-InitializingBean-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.1.</span> <span class="toc-text">演示 - Aware 接口及 InitializingBean 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-11"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-11"><span class="toc-number">1.6.2.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%B1%BB-Autowired-%E5%A4%B1%E6%95%88%E5%88%86%E6%9E%90"><span class="toc-number">1.6.3.</span> <span class="toc-text">配置类 @Autowired 失效分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%94%80%E6%AF%81"><span class="toc-number">1.7.</span> <span class="toc-text">7) 初始化与销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%94%80%E6%AF%81%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.7.1.</span> <span class="toc-text">演示 - 初始化销毁顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-12"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-12"><span class="toc-number">1.7.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Scope"><span class="toc-number">1.8.</span> <span class="toc-text">8) Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA1-request-session-application-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.8.1.</span> <span class="toc-text">演示1 - request, session, application 作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-13"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-13"><span class="toc-number">1.8.2.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-singleton-%E6%B3%A8%E5%85%A5%E5%85%B6%E5%AE%83-scope-%E5%A4%B1%E6%95%88"><span class="toc-number">1.8.3.</span> <span class="toc-text">分析 - singleton 注入其它 scope 失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA2-4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.4.</span> <span class="toc-text">演示2 - 4种解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-14"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-14"><span class="toc-number">1.8.5.</span> <span class="toc-text">收获💡</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP"><span class="toc-number">2.</span> <span class="toc-text">AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-AOP-%E5%AE%9E%E7%8E%B0%E4%B9%8B-ajc-%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">9) AOP 实现之 ajc 编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-15"><span class="toc-number">2.1.1.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-AOP-%E5%AE%9E%E7%8E%B0%E4%B9%8B-agent-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.2.</span> <span class="toc-text">10) AOP 实现之 agent 类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-16"><span class="toc-number">2.2.1.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-AOP-%E5%AE%9E%E7%8E%B0%E4%B9%8B-proxy"><span class="toc-number">2.3.</span> <span class="toc-text">11) AOP 实现之 proxy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA1-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">演示1 - jdk 动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-17"><span class="toc-number">2.3.2.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA2-cglib-%E4%BB%A3%E7%90%86"><span class="toc-number">2.3.3.</span> <span class="toc-text">演示2 - cglib 代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-18"><span class="toc-number">2.3.4.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%BF%9B%E9%98%B6"><span class="toc-number">2.4.</span> <span class="toc-text">12) jdk 动态代理进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA1-%E6%A8%A1%E6%8B%9F-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">2.4.1.</span> <span class="toc-text">演示1 - 模拟 jdk 动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-19"><span class="toc-number">2.4.2.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA2-%E6%96%B9%E6%B3%95%E5%8F%8D%E5%B0%84%E4%BC%98%E5%8C%96"><span class="toc-number">2.4.3.</span> <span class="toc-text">演示2 - 方法反射优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-15"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-20"><span class="toc-number">2.4.4.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-cglib-%E4%BB%A3%E7%90%86%E8%BF%9B%E9%98%B6"><span class="toc-number">2.5.</span> <span class="toc-text">13) cglib 代理进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E6%A8%A1%E6%8B%9F-cglib-%E4%BB%A3%E7%90%86"><span class="toc-number">2.5.1.</span> <span class="toc-text">演示 - 模拟 cglib 代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-16"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-21"><span class="toc-number">2.5.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-cglib-%E9%81%BF%E5%85%8D%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8"><span class="toc-number">2.6.</span> <span class="toc-text">14) cglib 避免反射调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-cglib-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8F%8D%E5%B0%84"><span class="toc-number">2.6.1.</span> <span class="toc-text">演示 - cglib 如何避免反射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-17"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-22"><span class="toc-number">2.6.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-jdk-%E5%92%8C-cglib-%E5%9C%A8-Spring-%E4%B8%AD%E7%9A%84%E7%BB%9F%E4%B8%80"><span class="toc-number">2.7.</span> <span class="toc-text">15) jdk 和 cglib 在 Spring 中的统一</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E5%BA%95%E5%B1%82%E5%88%87%E7%82%B9%E3%80%81%E9%80%9A%E7%9F%A5%E3%80%81%E5%88%87%E9%9D%A2"><span class="toc-number">2.7.1.</span> <span class="toc-text">演示 - 底层切点、通知、切面</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-18"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-23"><span class="toc-number">2.7.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%88%87%E7%82%B9%E5%8C%B9%E9%85%8D"><span class="toc-number">2.8.</span> <span class="toc-text">16) 切点匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E5%88%87%E7%82%B9%E5%8C%B9%E9%85%8D"><span class="toc-number">2.8.1.</span> <span class="toc-text">演示 - 切点匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-19"><span class="toc-number">2.8.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-24"><span class="toc-number">2.8.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E4%BB%8E-Aspect-%E5%88%B0-Advisor"><span class="toc-number">2.9.</span> <span class="toc-text">17) 从 @Aspect 到 Advisor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA1-%E4%BB%A3%E7%90%86%E5%88%9B%E5%BB%BA%E5%99%A8"><span class="toc-number">2.9.1.</span> <span class="toc-text">演示1 - 代理创建器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-20"><span class="toc-number">2.9.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-25"><span class="toc-number">2.9.2.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA2-%E4%BB%A3%E7%90%86%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="toc-number">2.9.3.</span> <span class="toc-text">演示2 - 代理创建时机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-21"><span class="toc-number">2.9.3.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-26"><span class="toc-number">2.9.4.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA3-Before-%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BD%8E%E7%BA%A7%E9%80%9A%E7%9F%A5"><span class="toc-number">2.9.5.</span> <span class="toc-text">演示3 - @Before 对应的低级通知</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-22"><span class="toc-number">2.9.5.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-27"><span class="toc-number">2.9.6.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E9%9D%99%E6%80%81%E9%80%9A%E7%9F%A5%E8%B0%83%E7%94%A8"><span class="toc-number">2.10.</span> <span class="toc-text">18) 静态通知调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA1-%E9%80%9A%E7%9F%A5%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">2.10.1.</span> <span class="toc-text">演示1 - 通知调用过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-23"><span class="toc-number">2.10.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-28"><span class="toc-number">2.10.2.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA2-%E6%A8%A1%E6%8B%9F-MethodInvocation"><span class="toc-number">2.10.3.</span> <span class="toc-text">演示2 - 模拟 MethodInvocation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-24"><span class="toc-number">2.10.3.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-29"><span class="toc-number">2.10.4.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%8A%A8%E6%80%81%E9%80%9A%E7%9F%A5%E8%B0%83%E7%94%A8"><span class="toc-number">2.11.</span> <span class="toc-text">19) 动态通知调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E5%B8%A6%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E7%9A%84%E9%80%9A%E7%9F%A5%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">2.11.1.</span> <span class="toc-text">演示 - 带参数绑定的通知方法调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-25"><span class="toc-number">2.11.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-30"><span class="toc-number">2.11.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WEB"><span class="toc-number">3.</span> <span class="toc-text">WEB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-RequestMappingHandlerMapping-%E4%B8%8E-RequestMappingHandlerAdapter"><span class="toc-number">3.1.</span> <span class="toc-text">20) RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA1-DispatcherServlet-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.1.</span> <span class="toc-text">演示1 - DispatcherServlet 初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-26"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-31"><span class="toc-number">3.1.2.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">3.1.3.</span> <span class="toc-text">演示2 - 自定义参数与返回值处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-27"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-32"><span class="toc-number">3.1.4.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">21) 参数解析器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">演示 - 常见参数解析器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-28"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-33"><span class="toc-number">3.2.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%8F%82%E6%95%B0%E5%90%8D%E8%A7%A3%E6%9E%90"><span class="toc-number">3.3.</span> <span class="toc-text">22) 参数名解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E5%90%8D"><span class="toc-number">3.3.1.</span> <span class="toc-text">演示 - 两种方法获取参数名</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-29"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-34"><span class="toc-number">3.3.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.</span> <span class="toc-text">23) 对象绑定与类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E7%AC%AC%E4%B8%80%E5%A5%97%E8%BD%AC%E6%8D%A2%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.1.</span> <span class="toc-text">底层第一套转换接口与实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E7%AC%AC%E4%BA%8C%E5%A5%97%E8%BD%AC%E6%8D%A2%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.4.2.</span> <span class="toc-text">底层第二套转换接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%B1%82%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.3.</span> <span class="toc-text">高层接口与实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA1-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-number">3.4.4.</span> <span class="toc-text">演示1 - 类型转换与数据绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-30"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-35"><span class="toc-number">3.4.5.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA2-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%B7%A5%E5%8E%82"><span class="toc-number">3.4.6.</span> <span class="toc-text">演示2 - 数据绑定工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-31"><span class="toc-number">3.4.6.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-36"><span class="toc-number">3.4.7.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA3-%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">3.4.8.</span> <span class="toc-text">演示3 - 获取泛型参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-32"><span class="toc-number">3.4.8.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-37"><span class="toc-number">3.4.9.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-ControllerAdvice-%E4%B9%8B-InitBinder"><span class="toc-number">3.5.</span> <span class="toc-text">24) @ControllerAdvice 之 @InitBinder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E5%87%86%E5%A4%87-InitBinder"><span class="toc-number">3.5.1.</span> <span class="toc-text">演示 - 准备 @InitBinder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-38"><span class="toc-number">3.5.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.6.</span> <span class="toc-text">25) 控制器方法执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE1"><span class="toc-number">3.6.1.</span> <span class="toc-text">图1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE2"><span class="toc-number">3.6.2.</span> <span class="toc-text">图2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE3"><span class="toc-number">3.6.3.</span> <span class="toc-text">图3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-ControllerAdvice-%E4%B9%8B-ModelAttribute"><span class="toc-number">3.7.</span> <span class="toc-text">26) @ControllerAdvice 之 @ModelAttribute</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E5%87%86%E5%A4%87-ModelAttribute"><span class="toc-number">3.7.1.</span> <span class="toc-text">演示 - 准备 @ModelAttribute</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-33"><span class="toc-number">3.7.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-39"><span class="toc-number">3.7.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">3.8.</span> <span class="toc-text">27) 返回值处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E5%B8%B8%E8%A7%81%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">3.8.1.</span> <span class="toc-text">演示 - 常见返回值处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-34"><span class="toc-number">3.8.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-40"><span class="toc-number">3.8.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-MessageConverter"><span class="toc-number">3.9.</span> <span class="toc-text">28) MessageConverter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-MessageConverter-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.9.1.</span> <span class="toc-text">演示 - MessageConverter 的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-35"><span class="toc-number">3.9.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-41"><span class="toc-number">3.9.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-ControllerAdvice-%E4%B9%8B-ResponseBodyAdvice"><span class="toc-number">3.10.</span> <span class="toc-text">29) @ControllerAdvice 之 ResponseBodyAdvice</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-ResponseBodyAdvice-%E5%A2%9E%E5%BC%BA"><span class="toc-number">3.10.1.</span> <span class="toc-text">演示 - ResponseBodyAdvice 增强</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-36"><span class="toc-number">3.10.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-42"><span class="toc-number">3.10.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E5%BC%82%E5%B8%B8%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">3.11.</span> <span class="toc-text">30) 异常解析器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-ExceptionHandlerExceptionResolver"><span class="toc-number">3.11.1.</span> <span class="toc-text">演示 - ExceptionHandlerExceptionResolver</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-37"><span class="toc-number">3.11.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-43"><span class="toc-number">3.11.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-ControllerAdvice-%E4%B9%8B-ExceptionHandler"><span class="toc-number">3.12.</span> <span class="toc-text">31) @ControllerAdvice 之 @ExceptionHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E5%87%86%E5%A4%87-ExceptionHandler"><span class="toc-number">3.12.1.</span> <span class="toc-text">演示 - 准备 @ExceptionHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-38"><span class="toc-number">3.12.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-44"><span class="toc-number">3.12.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-Tomcat-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">3.13.</span> <span class="toc-text">32) Tomcat 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA1-%E9%94%99%E8%AF%AF%E9%A1%B5%E5%A4%84%E7%90%86"><span class="toc-number">3.13.1.</span> <span class="toc-text">演示1 - 错误页处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-1"><span class="toc-number">3.13.1.1.</span> <span class="toc-text">关键代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-45"><span class="toc-number">3.13.2.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA2-BasicErrorController"><span class="toc-number">3.13.3.</span> <span class="toc-text">演示2 - BasicErrorController</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-2"><span class="toc-number">3.13.3.1.</span> <span class="toc-text">关键代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-46"><span class="toc-number">3.13.4.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-BeanNameUrlHandlerMapping-%E4%B8%8E-SimpleControllerHandlerAdapter"><span class="toc-number">3.14.</span> <span class="toc-text">33) BeanNameUrlHandlerMapping 与 SimpleControllerHandlerAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E6%9C%AC%E7%BB%84%E6%98%A0%E5%B0%84%E5%99%A8%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">3.14.1.</span> <span class="toc-text">演示 - 本组映射器和适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-3"><span class="toc-number">3.14.1.1.</span> <span class="toc-text">关键代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-47"><span class="toc-number">3.14.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-RouterFunctionMapping-%E4%B8%8E-HandlerFunctionAdapter"><span class="toc-number">3.15.</span> <span class="toc-text">34) RouterFunctionMapping 与 HandlerFunctionAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E6%9C%AC%E7%BB%84%E6%98%A0%E5%B0%84%E5%99%A8%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8-1"><span class="toc-number">3.15.1.</span> <span class="toc-text">演示 - 本组映射器和适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-4"><span class="toc-number">3.15.1.1.</span> <span class="toc-text">关键代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-48"><span class="toc-number">3.15.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-SimpleUrlHandlerMapping-%E4%B8%8E-HttpRequestHandlerAdapter"><span class="toc-number">3.16.</span> <span class="toc-text">35) SimpleUrlHandlerMapping 与 HttpRequestHandlerAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA1-%E6%9C%AC%E7%BB%84%E6%98%A0%E5%B0%84%E5%99%A8%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">3.16.1.</span> <span class="toc-text">演示1 - 本组映射器和适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-39"><span class="toc-number">3.16.1.1.</span> <span class="toc-text">代码参考</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-5"><span class="toc-number">3.16.1.2.</span> <span class="toc-text">关键代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-49"><span class="toc-number">3.16.2.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA2-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90%E4%BC%98%E5%8C%96"><span class="toc-number">3.16.3.</span> <span class="toc-text">演示2 - 静态资源解析优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-6"><span class="toc-number">3.16.3.1.</span> <span class="toc-text">关键代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-50"><span class="toc-number">3.16.4.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA3-%E6%AC%A2%E8%BF%8E%E9%A1%B5"><span class="toc-number">3.16.5.</span> <span class="toc-text">演示3 - 欢迎页</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-7"><span class="toc-number">3.16.5.1.</span> <span class="toc-text">关键代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-51"><span class="toc-number">3.16.6.</span> <span class="toc-text">收获💡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%99%A8%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8%E5%B0%8F%E7%BB%93"><span class="toc-number">3.16.7.</span> <span class="toc-text">映射器与适配器小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-mvc-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">3.17.</span> <span class="toc-text">36) mvc 处理流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boot"><span class="toc-number">4.</span> <span class="toc-text">Boot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#37-Boot-%E9%AA%A8%E6%9E%B6%E9%A1%B9%E7%9B%AE"><span class="toc-number">4.1.</span> <span class="toc-text">37) Boot 骨架项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-Boot-War%E9%A1%B9%E7%9B%AE"><span class="toc-number">4.2.</span> <span class="toc-text">38) Boot War项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E7%A4%BA"><span class="toc-number">4.2.2.</span> <span class="toc-text">启示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-Boot-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">39) Boot 启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">演示 - 启动过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-52"><span class="toc-number">4.3.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-Tomcat-%E5%86%85%E5%B5%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">40) Tomcat 内嵌容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA1-Tomcat-%E5%86%85%E5%B5%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">4.4.1.</span> <span class="toc-text">演示1 - Tomcat 内嵌容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-8"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">关键代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA2-%E9%9B%86%E6%88%90-Spring-%E5%AE%B9%E5%99%A8"><span class="toc-number">4.4.2.</span> <span class="toc-text">演示2 - 集成 Spring 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-9"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">关键代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-Boot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">4.5.</span> <span class="toc-text">41) Boot 自动配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AopAutoConfiguration"><span class="toc-number">4.5.1.</span> <span class="toc-text">AopAutoConfiguration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DataSourceAutoConfiguration"><span class="toc-number">4.5.2.</span> <span class="toc-text">DataSourceAutoConfiguration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MybatisAutoConfiguration"><span class="toc-number">4.5.3.</span> <span class="toc-text">MybatisAutoConfiguration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TransactionAutoConfiguration"><span class="toc-number">4.5.4.</span> <span class="toc-text">TransactionAutoConfiguration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServletWebServerFactoryAutoConfiguration"><span class="toc-number">4.5.5.</span> <span class="toc-text">ServletWebServerFactoryAutoConfiguration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DispatcherServletAutoConfiguration"><span class="toc-number">4.5.6.</span> <span class="toc-text">DispatcherServletAutoConfiguration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebMvcAutoConfiguration"><span class="toc-number">4.5.7.</span> <span class="toc-text">WebMvcAutoConfiguration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ErrorMvcAutoConfiguration"><span class="toc-number">4.5.8.</span> <span class="toc-text">ErrorMvcAutoConfiguration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MultipartAutoConfiguration"><span class="toc-number">4.5.9.</span> <span class="toc-text">MultipartAutoConfiguration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HttpEncodingAutoConfiguration"><span class="toc-number">4.5.10.</span> <span class="toc-text">HttpEncodingAutoConfiguration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%8E%9F%E7%90%86"><span class="toc-number">4.5.11.</span> <span class="toc-text">演示 - 自动配置类原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-10"><span class="toc-number">4.5.11.1.</span> <span class="toc-text">关键代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-53"><span class="toc-number">4.5.12.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E6%9D%A1%E4%BB%B6%E8%A3%85%E9%85%8D%E5%BA%95%E5%B1%82"><span class="toc-number">4.6.</span> <span class="toc-text">42) 条件装配底层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-54"><span class="toc-number">4.6.1.</span> <span class="toc-text">收获💡</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">5.</span> <span class="toc-text">其它</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#43-FactoryBean"><span class="toc-number">5.1.</span> <span class="toc-text">43) FactoryBean</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-FactoryBean"><span class="toc-number">5.1.1.</span> <span class="toc-text">演示 - FactoryBean</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-40"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-55"><span class="toc-number">5.1.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-Indexed-%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">44) @Indexed 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-Indexed"><span class="toc-number">5.2.1.</span> <span class="toc-text">演示 - @Indexed</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-41"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-56"><span class="toc-number">5.2.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E4%BB%A3%E7%90%86%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3"><span class="toc-number">5.3.</span> <span class="toc-text">45) 代理进一步理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E4%BB%A3%E7%90%86"><span class="toc-number">5.3.1.</span> <span class="toc-text">演示 - 代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-42"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-57"><span class="toc-number">5.3.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-Value-%E8%A3%85%E9%85%8D%E5%BA%95%E5%B1%82"><span class="toc-number">5.4.</span> <span class="toc-text">46) @Value 装配底层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E7%B1%BB%E5%9E%8B%E8%A3%85%E9%85%8D%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.4.1.</span> <span class="toc-text">按类型装配的步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-Value-%E8%A3%85%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">5.4.2.</span> <span class="toc-text">演示 - @Value 装配过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-43"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-58"><span class="toc-number">5.4.3.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-Autowired-%E8%A3%85%E9%85%8D%E5%BA%95%E5%B1%82"><span class="toc-number">5.5.</span> <span class="toc-text">47) @Autowired 装配底层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-Autowired-%E8%A3%85%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">5.5.1.</span> <span class="toc-text">演示 - @Autowired 装配过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-44"><span class="toc-number">5.5.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-59"><span class="toc-number">5.5.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">5.6.</span> <span class="toc-text">48) 事件监听器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">5.6.1.</span> <span class="toc-text">演示 - 事件监听器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-45"><span class="toc-number">5.6.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-60"><span class="toc-number">5.6.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E5%99%A8"><span class="toc-number">5.7.</span> <span class="toc-text">49) 事件发布器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E5%99%A8"><span class="toc-number">5.7.1.</span> <span class="toc-text">演示 - 事件发布器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83-46"><span class="toc-number">5.7.1.1.</span> <span class="toc-text">代码参考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%F0%9F%92%A1-61"><span class="toc-number">5.7.2.</span> <span class="toc-text">收获💡</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2f7a06ce.html" title="🧠ChatGPT 中文调教指南"><img src="https://upyun.goku.top/blog/post_banner_11.jpeg?_r_=4368ceda-0914-6a44-6fc4-a1233c5e3de3" onerror="this.onerror=null;this.src='https://upyun.goku.top/blog/error.jpg'" alt="🧠ChatGPT 中文调教指南"/></a><div class="content"><a class="title" href="/posts/2f7a06ce.html" title="🧠ChatGPT 中文调教指南">🧠ChatGPT 中文调教指南</a><time datetime="2024-10-19T04:45:36.000Z" title="发表于 2024-10-19 12:45:36">2024-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f34cb02b.html" title="TVBox接口备忘"><img src="https://upyun.goku.top/blog/post_banner_7.jpeg?_r_=e1a8d92c-592b-13f8-88c5-2801feef081e" onerror="this.onerror=null;this.src='https://upyun.goku.top/blog/error.jpg'" alt="TVBox接口备忘"/></a><div class="content"><a class="title" href="/posts/f34cb02b.html" title="TVBox接口备忘">TVBox接口备忘</a><time datetime="2024-10-05T20:22:37.458Z" title="发表于 2024-10-06 04:22:37">2024-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20e6247.html" title="docker构建多平台镜像"><img src="https://upyun.goku.top/blog/docker.jpeg" onerror="this.onerror=null;this.src='https://upyun.goku.top/blog/error.jpg'" alt="docker构建多平台镜像"/></a><div class="content"><a class="title" href="/posts/20e6247.html" title="docker构建多平台镜像">docker构建多平台镜像</a><time datetime="2024-08-30T13:20:43.000Z" title="发表于 2024-08-30 21:20:43">2024-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3a71ca1d.html" title="nginx转发请求丢失自定义请求头"><img src="https://upyun.goku.top/blog/post_banner_5.jpeg?_r_=579af843-e4df-3009-be93-2416b88aba45" onerror="this.onerror=null;this.src='https://upyun.goku.top/blog/error.jpg'" alt="nginx转发请求丢失自定义请求头"/></a><div class="content"><a class="title" href="/posts/3a71ca1d.html" title="nginx转发请求丢失自定义请求头">nginx转发请求丢失自定义请求头</a><time datetime="2024-08-30T13:20:43.000Z" title="发表于 2024-08-30 21:20:43">2024-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5dd44277.html" title="QuantumultX在访问指定网站时，运行指定脚本"><img src="https://upyun.goku.top/blog/QuantumultX.png" onerror="this.onerror=null;this.src='https://upyun.goku.top/blog/error.jpg'" alt="QuantumultX在访问指定网站时，运行指定脚本"/></a><div class="content"><a class="title" href="/posts/5dd44277.html" title="QuantumultX在访问指定网站时，运行指定脚本">QuantumultX在访问指定网站时，运行指定脚本</a><time datetime="2023-11-16T12:14:16.000Z" title="发表于 2023-11-16 20:14:16">2023-11-16</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:1104657149@qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/sgr997" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src="https://upyun.goku.top/white/avatar.JPG" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/49499302" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" href="/copyright" title="CC"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i></a></div><div id="workboard"><img class="workSituationImg boardsign" src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><div class="footer_custom_text"><div style="display:flex;justify-content:center;"> <span>本网站由</span> <a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="blank" title="又拍云"> <img height="24px" width="45px" stype="height:24px;display:inline" src="https://static.allasone.cc/source/upyun_logo.png" alt="又拍云"/> </a> <span>提供CDN加速/云存储服务</span> </div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="Pei" target="_blank">Pei</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="豫ICP备2023023872号">豫ICP备2023023872号</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">26</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.goku.top/webstack.html" title="网址导航"><img class="back-menu-item-icon" src="https://upyun.goku.top/blog/icon.png!cover" alt="网址导航"/><span class="back-menu-item-text">网址导航</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="fa-solid fa-music faa-tada"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lightbulb"></use></svg><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 0.88rem;">AI<sup>1</sup></a><a href="/tags/GPT/" style="font-size: 0.88rem;">GPT<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>1</sup></a><a href="/tags/IntelliJ-IDEA/" style="font-size: 0.88rem;">IntelliJ IDEA<sup>1</sup></a><a href="/tags/JVM/" style="font-size: 0.88rem;">JVM<sup>2</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>16</sup></a><a href="/tags/Netty/" style="font-size: 0.88rem;">Netty<sup>4</sup></a><a href="/tags/Python/" style="font-size: 0.88rem;">Python<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>3</sup></a><a href="/tags/TVBox/" style="font-size: 0.88rem;">TVBox<sup>1</sup></a><a href="/tags/blog/" style="font-size: 0.88rem;">blog<sup>3</sup></a><a href="/tags/docker/" style="font-size: 0.88rem;">docker<sup>2</sup></a><a href="/tags/frp/" style="font-size: 0.88rem;">frp<sup>1</sup></a><a href="/tags/ios/" style="font-size: 0.88rem;">ios<sup>2</sup></a><a href="/tags/macos/" style="font-size: 0.88rem;">macos<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>2</sup></a><a href="/tags/nginx/" style="font-size: 0.88rem;">nginx<sup>1</sup></a><a href="/tags/redis/" style="font-size: 0.88rem;">redis<sup>2</sup></a><a href="/tags/trollstore/" style="font-size: 0.88rem;">trollstore<sup>1</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" style="font-size: 0.88rem;">内网穿透<sup>1</sup></a><a href="/tags/%E5%A5%87%E6%80%AA%E7%9A%84%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">奇怪的知识<sup>2</sup></a><a href="/tags/%E5%A8%B1%E4%B9%90/" style="font-size: 0.88rem;">娱乐<sup>2</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">学习<sup>2</sup></a><a href="/tags/%E5%AE%89%E5%8D%93/" style="font-size: 0.88rem;">安卓<sup>2</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">工具<sup>2</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" style="font-size: 0.88rem;">开发问题记录<sup>4</sup></a><a href="/tags/%E5%BD%B1%E9%9F%B3/" style="font-size: 0.88rem;">影音<sup>1</sup></a><a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 0.88rem;">生活<sup>4</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>3</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 0.88rem;">项目<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.6/translate/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.14/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("12/13/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Pei 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("12/13/2021 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/mermaid/8.14.0/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.goku.top/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/twikoo/1.4.18/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.goku.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.goku.top/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/twikoo/1.4.18/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@goku.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script>let tianliGPT_postSelector = '\#post \#article-container';let tianliGPT_postURL = '\*/posts/\*';let tianliGPT_key = '123';</script><script data-pjax src="/html/js/summ.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>